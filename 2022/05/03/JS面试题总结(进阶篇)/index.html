<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Continue Study">
    
    <title>
        
            JS面试题总结(进阶篇) |
        
        Continue Study
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/1.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.compost_asset_folder","root":"/","language":"zh-Hans","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/1.jpg","favicon":"/images/1.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"黄色的森林分出两条路，我选择了人迹更少的那一条，从此决定我一生的道路。"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Continue Study
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                目录
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">目录</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">JS面试题总结(进阶篇)</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/1.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Continue Study</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-05-03 18:37:32</span>
        <span class="mobile">2022-05-03 18:37</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">面试题总结</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.4k 字數</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>18 分鐘</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>面试题 链接：</p>
<p>前端面试指南 </p>
<p><a class="link"   target="_blank" rel="noopener" href="https://interview2.poetries.top/docs/base.html" >https://interview2.poetries.top/docs/base.html<i class="fas fa-external-link-alt"></i></a></p>
<p>邮箱：<a class="link"   href="mailto:&#49;&#x38;&#48;&#x31;&#x30;&#48;&#55;&#x37;&#x30;&#x32;&#x36;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;" >&#49;&#x38;&#48;&#x31;&#x30;&#48;&#55;&#x37;&#x30;&#x32;&#x36;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a></p>
<p>web前端面试-面试官系列：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/vue.html" >https://vue3js.cn/interview/vue/vue.html<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="类型及检测方式"><a href="#类型及检测方式" class="headerlink" title="类型及检测方式"></a>类型及检测方式</h1><h2 id="JavaScript一共有8种数据类型，"><a href="#JavaScript一共有8种数据类型，" class="headerlink" title="JavaScript一共有8种数据类型，"></a><code>JavaScript</code>一共有8种数据类型，</h2><p>7种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>（<code>es6</code>新增，表示独一无二的值）和<code>BigInt</code>（<code>es10</code>新增）；</p>
<p>1种引用数据类型——<code>Object</code>（Object本质上是由一组无序的名值对组成的）</p>
<h2 id="JS数据类型分为两类进行存储："><a href="#JS数据类型分为两类进行存储：" class="headerlink" title="JS数据类型分为两类进行存储："></a>JS数据类型分为两类进行存储：</h2><ul>
<li><strong>基本数据类型</strong>：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</li>
<li><strong>引用数据类型</strong>：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<h2 id="JavaScript-中的数据是如何存储在内存中的？"><a href="#JavaScript-中的数据是如何存储在内存中的？" class="headerlink" title="JavaScript 中的数据是如何存储在内存中的？"></a><strong>JavaScript 中的数据是如何存储在内存中的？</strong></h2><p>在 JavaScript 中，基本类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>
<p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<code>代码空间</code>、<code>栈空间</code>、<code>堆空间</code>。其中的代码空间主要是存储可执行代码的，原始类型(<code>Number、String、Null、Undefined、Boolean、Symbol、BigInt</code>)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。</p>
<p>因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在”堆空间”中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>
<h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><p><strong>（1）typeof</strong></p>
<p>​			typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p>
<p>​			typeof<code>对于对象来说，除了函数都会显示</code>object</p>
<p>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code></p>
<p><strong>2）instanceof</strong></p>
<p>​	instanceof<code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的</code>prototype</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>首先我们要知道，在 <code>JS</code> 中类型转换只有三种情况，分别是：</p>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转换为字符串</li>
</ul>
<h2 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a><strong>null 和 undefined 的区别？</strong></h2><p> 首先 <code>Undefined</code> 和 <code>Null</code> 都是基本数据类型，</p>
<p><code>undefined</code> 代表的含义是未定义， <code>null</code> 代表的含义是空对象</p>
<h1 id="This"><a href="#This" class="headerlink" title="This"></a>This</h1><p>this总是指向函数的直接调用者，当有new关键字时，this会指向new出来的那个对象，</p>
<h2 id="函数执行改变this"><a href="#函数执行改变this" class="headerlink" title="函数执行改变this"></a><strong>函数执行改变this</strong></h2><ul>
<li><code>call: fn.call(target, 1, 2)</code></li>
<li><code>apply: fn.apply(target, [1, 2])</code></li>
<li><code>bind: fn.bind(target)(1,2)</code></li>
</ul>
<h1 id="apply-x2F-call-x2F-bind-原理"><a href="#apply-x2F-call-x2F-bind-原理" class="headerlink" title="apply&#x2F;call&#x2F;bind 原理"></a>apply&#x2F;call&#x2F;bind 原理</h1><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p>通常提升的解释是说将声明的代码移动到了顶部，</p>
<p>更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，<code>JS</code> 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用</p>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>当执行 JS 代码时，会产生三种执行上下文</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code> 执行上下文</li>
</ul>
<blockquote>
<p>每个执行上下文中都有三个重要的属性</p>
</blockquote>
<ul>
<li>变量对象（<code>VO</code>），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li>
<li>作用域链（<code>JS</code> 采用词法作用域，也就是说变量的作用域是在定义时就决定了）</li>
<li><code>this</code></li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p><strong>作用域</strong>： 作用域是定义变量的区域，</p>
<p>作用域可以理解为变量的可访问性，总共分为三种类型，分别为：</p>
<ul>
<li><strong>全局作用域</strong> &#x3D;&#x3D;&gt;	全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量</li>
<li><strong>函数作用域</strong> &#x3D;&#x3D;&gt;     函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域</li>
<li><strong>块级作用域</strong> &#x3D;&#x3D;&gt;     ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。</li>
</ul>
<p><strong>作用域链</strong>： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。</p>
<p><strong>作用域链的本质</strong>上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包其实就是一个可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，创建一个闭包最常见的方法就是在一个函数中创建另一个函数，它有三个特性，1：函数内可以再嵌套函数，2：内部函数可以访问外部的方法和变量，3：方法和变量不会被垃圾回收机制回收，</p>
<h1 id="New的原理"><a href="#New的原理" class="headerlink" title="New的原理"></a>New的原理</h1><ol>
<li>创建一个新对象</li>
<li>对象连接到构造函数原型上，并绑定 <code>this</code>（this 指向新对象）</li>
<li>执行构造函数代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<h2 id="new-被调用后大致做了哪几件事情"><a href="#new-被调用后大致做了哪几件事情" class="headerlink" title="new 被调用后大致做了哪几件事情"></a><strong>new 被调用后大致做了哪几件事情</strong></h2><ul>
<li>让实例可以访问到私有属性；</li>
<li>让实例可以访问构造函数原型（<code>constructor.prototype</code>）所在原型链上的属性；</li>
<li>构造函数返回的最后结果是引用数据类型。</li>
</ul>
<h1 id="原型-x2F-原型链"><a href="#原型-x2F-原型链" class="headerlink" title="原型&#x2F;原型链"></a>原型&#x2F;原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，直到找到或undefined，这个就是原型链的概念。</p>
<ul>
<li>原型(<code>prototype</code>): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 <code>Firefox</code> 和 <code>Chrome</code> 中，每个<code>JavaScript</code>对象中都包含一个<code>__proto__</code>(非标准)的属性指向它爹(该对象的原型)，可<code>obj.__proto__</code>进行访问。</li>
<li>构造函数: 可以通过<code>new</code>来 新建一个对象 的函数。</li>
<li>实例: 通过构造函数和<code>new</code>创建出来的对象，便是实例。 实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li>
</ul>
<h2 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="headerlink" title="js 获取原型的方法"></a><strong>js 获取原型的方法</strong></h2><ul>
<li><code>p.proto</code></li>
<li><code>p.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(p)</code></li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>1，<strong>组合继承</strong>		组合继承是最常用的继承方式</p>
<p>2，<strong>Class 继承</strong></p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul>
<li><p>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</p>
</li>
<li><p>优点</p>
<ul>
<li>易维护<ul>
<li>采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的</li>
</ul>
</li>
<li>易扩展</li>
<li>开发工作的重用性、继承性高，降低重复工作量。</li>
<li>缩短了开发周期</li>
</ul>
</li>
</ul>
<p>一般面向对象包含：继承，封装，多态，抽象</p>
<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><p><strong>事件流有三个阶段</strong></p>
<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
<p><strong>事件捕获</strong></p>
<blockquote>
<p>事件捕获（<code>event capturing</code>）：通俗的理解就是，当鼠标点击或者触发<code>dom</code>事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</p>
</blockquote>
<p><strong>事件冒泡</strong></p>
<blockquote>
<p>事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点</p>
</blockquote>
<p>无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播</p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><blockquote>
<p>js 中现在比较成熟的有四种模块加载方案：</p>
</blockquote>
<ul>
<li>第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</li>
<li>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范</li>
<li>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</li>
<li>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块</li>
</ul>
<h2 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a><strong>AMD 和 CMD 规范的区别？</strong></h2><p>第一个方面是在模块定义时对依赖的处理不同，AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</p>
<p>第二个方面是对依赖模块的执行时机处理不同，首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，</p>
<h2 id="谈谈对模块化开发的理解"><a href="#谈谈对模块化开发的理解" class="headerlink" title="谈谈对模块化开发的理解"></a><strong>谈谈对模块化开发的理解</strong></h2><ul>
<li>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</li>
<li>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</li>
<li>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</li>
<li>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</li>
</ul>
<h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><p><code>Iterator</code>（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署<code>Iterator</code>接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p><strong>Iterator 的作用有三个：</strong></p>
<ul>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li><code>Promise</code> 是 <code>ES6</code> 新增的语法，解决了回调地狱的问题。</li>
</ul>
<p><strong>回调地狱概念：回调函数套回调函数的情况就叫做回调地狱，</strong></p>
<ul>
<li>可以把 <code>Promise</code>看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code>，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</li>
</ul>
<p>简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息</p>
<p>一般 Promise 在执行过程中，必然会处于以下几种状态之一。</p>
<ul>
<li>待定（<code>pending</code>）：初始状态，既没有被完成，也没有被拒绝。</li>
<li>已完成（<code>fulfilled</code>）：操作成功完成。</li>
<li>已拒绝（<code>rejected</code>）：操作失败。</li>
</ul>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p><code>Generator</code> 是 <code>ES6</code>中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程。Generator 最大的特点就是可以控制函数的执行。</p>
<p><code>Generator</code>函数是<code>ES6</code>提供的一种异步编程解决方案。通过<code>yield</code>标识位和<code>next()</code>方法调用，实现函数的分段执行</p>
<h1 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h1><p><code>Generator</code> 函数的语法糖。有更好的语义、更好的适用性、返回值是 <code>Promise</code>。</p>
<p>优缺点：<code>async/await</code>的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p>
<p><strong>async原理</strong></p>
<p><code>async/await</code>语法糖就是使用<code>Generator</code>函数+自动执行器来运作的</p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><ul>
<li><p>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行</p>
</li>
<li><p>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</p>
</li>
<li><p>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行</p>
</li>
<li><p>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行</p>
</li>
<li><p>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p>
</li>
<li><h2 id="微任务："><a href="#微任务：" class="headerlink" title="微任务："></a><strong>微任务</strong>：</h2><p>在 Node.js 中微任务包含 2 种——<code>process.nextTick</code> 和 <code>Promise</code>。<code>微任务在事件循环中优先级是最高的</code>，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且<code>process.nextTick 和 Promise</code>也存在优先级，<code>process.nextTick</code> 高于 <code>Promise</code></p>
</li>
<li><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2></li>
<li><p>在 Node.js 中宏任务包含 4 种——<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code> 和 <code>I/O</code>。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列</p>
</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ul>
<li><p>JavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。</p>
</li>
<li><p>针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数</p>
</li>
</ul>
<p>标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。</p>
<h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>意外的全局变量</p>
<p>定时器</p>
<p>事件监听:</p>
<p>闭包</p>
<p>循环对象引用:</p>
<p>控制台<code>console.log</code>打印的东西</p>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象</p>
<p><strong>但是使用 object.assign 方法有几点需要注意</strong></p>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 <code>Symbol</code> 类型的属性。</li>
</ul>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><code>浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝</code>。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。</p>
<p><strong>深拷贝的原理可以总结如下</strong></p>
<p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p>
<h1 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a>节流与防抖</h1><ul>
<li>函数防抖 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li>
<li>函数节流 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li>
</ul>
<h1 id="Proxy代理"><a href="#Proxy代理" class="headerlink" title="Proxy代理"></a>Proxy代理</h1><p>proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</p>
<p><strong>Proxy的作用</strong></p>
<blockquote>
<p>对于代理模式 <code>Proxy</code> 的作用主要体现在三个方面</p>
</blockquote>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><ul>
<li><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascrip</code>t来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li>
</ul>
<p><strong>ajax 有那些优缺点?</strong></p>
<ul>
<li>优点：<ul>
<li>通过异步模式，提升了用户体验.</li>
<li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li>
<li><code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>
<li><code>Ajax</code>可以实现动态不刷新（局部刷新）</li>
</ul>
</li>
<li>缺点：<ul>
<li>安全问题 <code>AJAX</code>暴露了与服务器交互的细节。</li>
<li>对搜索引擎的支持比较弱。</li>
<li>不容易调试。</li>
</ul>
</li>
</ul>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/05/04/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E5%9F%BA%E7%A1%80%E7%AF%87)/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">JS面试题总结(基础篇)</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/04/30/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">高频面试题总结</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Continue Study</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
            </div>
        
        <div class="theme-info info-item">
            <a target="_blank" href="https://hexo.io">Hexo</a> 框架&nbsp;|&nbsp;主題&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
            <div class="icp-info info-item"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">豫ICP证000000000001</a></div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">类型及检测方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript%E4%B8%80%E5%85%B1%E6%9C%898%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C"><span class="nav-number">1.1.</span> <span class="nav-text">JavaScript一共有8种数据类型，</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">JS数据类型分为两类进行存储：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">JavaScript 中的数据是如何存储在内存中的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B"><span class="nav-number">1.4.</span> <span class="nav-text">数据类型检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.5.</span> <span class="nav-text">数据类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">null 和 undefined 的区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#This"><span class="nav-number">2.</span> <span class="nav-text">This</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%94%B9%E5%8F%98this"><span class="nav-number">2.1.</span> <span class="nav-text">函数执行改变this</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#apply-x2F-call-x2F-bind-%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">apply&#x2F;call&#x2F;bind 原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-number">4.</span> <span class="nav-text">变量提升</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">5.</span> <span class="nav-text">执行上下文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">6.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">7.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#New%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">New的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E8%A2%AB%E8%B0%83%E7%94%A8%E5%90%8E%E5%A4%A7%E8%87%B4%E5%81%9A%E4%BA%86%E5%93%AA%E5%87%A0%E4%BB%B6%E4%BA%8B%E6%83%85"><span class="nav-number">8.1.</span> <span class="nav-text">new 被调用后大致做了哪几件事情</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B-x2F-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">9.</span> <span class="nav-text">原型&#x2F;原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-number">9.1.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">9.2.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.3.</span> <span class="nav-text">js 获取原型的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">10.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">事件机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">13.</span> <span class="nav-text">模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AMD-%E5%92%8C-CMD-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">AMD 和 CMD 规范的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">13.2.</span> <span class="nav-text">谈谈对模块化开发的理解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">14.</span> <span class="nav-text">Iterator迭代器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise"><span class="nav-number">15.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Generator"><span class="nav-number">16.</span> <span class="nav-text">Generator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async-x2F-await"><span class="nav-number">17.</span> <span class="nav-text">async&#x2F;await</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">18.</span> <span class="nav-text">事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9A"><span class="nav-number">18.1.</span> <span class="nav-text">微任务：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">18.2.</span> <span class="nav-text">宏任务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">19.</span> <span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">20.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">21.</span> <span class="nav-text">深浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">21.1.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">21.2.</span> <span class="nav-text">深拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96"><span class="nav-number">22.</span> <span class="nav-text">节流与防抖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Proxy%E4%BB%A3%E7%90%86"><span class="nav-number">23.</span> <span class="nav-text">Proxy代理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ajax"><span class="nav-number">24.</span> <span class="nav-text">Ajax</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜尋..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
