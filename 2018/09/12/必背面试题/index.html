<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Continue Study">
    
    <title>
        
            必背面试题 |
        
        Continue Study
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/1.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.compost_asset_folder","root":"/","language":"zh-Hans","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/1.jpg","favicon":"/images/1.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"黄色的森林分出两条路，我选择了人迹更少的那一条，从此决定我一生的道路。"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Continue Study
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                目录
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">目录</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">必背面试题</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/1.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Continue Study</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2018-09-12 09:11:29</span>
        <span class="mobile">2018-09-12 09:11</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">面试题总结</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>13.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>47 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="说说你对盒子模型的理解"><a href="#说说你对盒子模型的理解" class="headerlink" title="说说你对盒子模型的理解"></a>说说你对盒子模型的理解</h1><p>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）</p>
<p>一个盒子由四个部分组成：<code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code></p>
<p><code>content</code>，即实际内容，显示文本和图像</p>
<p><code>boreder</code>，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成</p>
<p><code>padding</code>，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的<code>background</code>属性影响</p>
<p><code>margin</code>，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域</p>
<p>在<code>CSS</code>中，盒子模型可以分成：</p>
<ul>
<li>W3C 标准盒子模型</li>
<li>IE 怪异盒子模型</li>
</ul>
<p>默认情况下，盒子模型为<code>W3C</code> 标准盒子模型</p>
<h2 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h2><p>标准盒子模型，是浏览器默认的盒子模型</p>
<p>也就是，<code>width/height</code> 只是内容高度，不包含 <code>padding</code> 和 <code>border</code>值</p>
<h2 id="IE-怪异盒子模型"><a href="#IE-怪异盒子模型" class="headerlink" title="IE 怪异盒子模型"></a>IE 怪异盒子模型</h2><p>也就是，<code>width/height</code> 包含了 <code>padding</code>和 <code>border值</code></p>
<h1 id="css选择器有哪些？优先级？"><a href="#css选择器有哪些？优先级？" class="headerlink" title="css选择器有哪些？优先级？"></a>css选择器有哪些？优先级？</h1><ul>
<li>id选择器（#box），选择id为box的元素</li>
<li>类选择器（.one），选择类名为one的所有元素</li>
<li>标签选择器（div），选择标签为div的所有元素</li>
<li>后代选择器（#box div），选择id为box元素内部所有的div元素</li>
<li>子选择器（.one&gt;one_1），选择父元素为.one的所有.one_1的元素</li>
<li>相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素</li>
<li>群组选择器（div,p），选择div、p的所有元素</li>
</ul>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>!important &gt;内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p>
<h2 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h2><p>在<code>css</code>中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性.</p>
<p>font-size, font-family, color</p>
<h1 id="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h1><p>实现元素水平垂直居中的方式：</p>
<ul>
<li><p>利用定位+margin:auto</p>
</li>
<li><p>利用定位+margin:负值</p>
</li>
<li><p>利用定位+transform</p>
</li>
<li><p>table布局</p>
</li>
<li><p>flex布局</p>
<ul>
<li>grid布局</li>
</ul>
<h1 id="怎么理解回流跟重绘？什么场景下会触发？"><a href="#怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="怎么理解回流跟重绘？什么场景下会触发？"></a>怎么理解回流跟重绘？什么场景下会触发？</h1></li>
</ul>
<p>回流：布局引擎会根据各种样式计算每个盒子在s页面上的大小与位置</p>
<p>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</p>
<p>· 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</p>
<p>· 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏&#x2F;状态状态）发生改变时，产生重绘回流</p>
<p>· 回流必将引起重绘，而重绘不一定会引起回流</p>
<h1 id="什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何做？</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>面对不同分辨率设备灵活性强</p>
<p>能够快捷解决多设备显示适应问题</p>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>仅适用布局、信息、框架并不复杂的部门类型网站</p>
<p>兼容各种设备工作量大，效率低下</p>
<p>代码累赘，会出现隐藏无用的元素，加载时间加长</p>
<p>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p>
<p>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>
<h1 id="如果要做优化，CSS提高性能的方法有哪些？"><a href="#如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="如果要做优化，CSS提高性能的方法有哪些？"></a>如果要做优化，CSS提高性能的方法有哪些？</h1><p>每一个网页都离不开<code>css</code>，但是很多人又认为，<code>css</code>主要是用来完成页面布局的，像一些细节或者优化，</p>
<p>减少css嵌套，最好不要套三层以上。</p>
<p>不要在ID选择器前面进行嵌套，ID本来就是唯一的而且人家权值那么大，嵌套完全是浪费性能。</p>
<p>建立公共样式类，把相同样式提取出来作为公共类使用，比如我们常用的清除浮动等。	</p>
<p>不用css表达式，表达式只是让你的代码显得更加炫酷，但是他对性能的浪费可能是超乎你的想象的。</p>
<h1 id="对前端工程师这个职位是怎么样理解的？它的前景会怎么样"><a href="#对前端工程师这个职位是怎么样理解的？它的前景会怎么样" class="headerlink" title="对前端工程师这个职位是怎么样理解的？它的前景会怎么样?"></a>对前端工程师这个职位是怎么样理解的？它的前景会怎么样?</h1><p>我认为前端工程师是最贴近用户的，是以用户需求为中心，通过不同的改进和亲身体验来完成用户的需求，让用户的交互效果更加舒服，</p>
<p>以前前端的可能就写一些页面，很简单的工作，现在可以通过vue，react等框架来让交互效果更加理想，也把后端的一些任务放到前端处理，所以，前端不仅仅要面对用户，还要面对，后端，产品经理，等所以前端并不局限于前端技术还要会一点后端，会一点产品， 每个前端人员往往都会往全栈的方向去发展，当然这也是我的一个目标，这就我对前端开发人员的理解+</p>
<h1 id="说说JavaScript中的数据类型？存储上的差别？"><a href="#说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="说说JavaScript中的数据类型？存储上的差别？"></a>说说JavaScript中的数据类型？存储上的差别？</h1><p>js的数据类型分为两类，一个是基本数据类型，一个是引用数据类型</p>
<p>基本数据类型有undefined<code>、</code>null<code>、</code>boolean<code>、</code>number<code>、</code>string<code>、</code>symbol</p>
<p>引用数据类型有	object</p>
<p>在js的执行过程中，主要有三种数据类型内存空间，分别是代码空间，栈空间，堆空间，其中的代码空间主要是存储可执行代码的，原始类型的数据值都是直接保存在栈中的，引用数据类型的值是存放在堆空间中的，   原始数据类型存储的是变量的值，而引用数据类型存储的是其在堆空间中的地址。</p>
<h1 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h1><p>typeof 对于原始数据类型来说，除了null都可以正确的显示类型</p>
<p>对于引用数据类型来说，除了函数，都会显示object  </p>
<p>这样看来typeof它并不能正确的显示数据类型，</p>
<p>instanceof 可以正确显示数据类型， 因为它是通过对象的原型链来进行判断的，</p>
<h1 id="说说你对闭包的理解？闭包使用场景"><a href="#说说你对闭包的理解？闭包使用场景" class="headerlink" title="说说你对闭包的理解？闭包使用场景"></a>说说你对闭包的理解？闭包使用场景</h1><p>闭包就是可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，创建一个闭包最简单的方法就是在一个函数内创建一个函数，它有三个特性是  函数内可以再嵌套函数，内部函数可以访问外部的方法和变量，方法和变量不会被垃圾回收机制回收，</p>
<p>它的优点就是可以实现封装和缓存，缺点就是可能会造成内存泄漏的问题</p>
<h1 id="bind、call、apply-区别？如何实现一个bind"><a href="#bind、call、apply-区别？如何实现一个bind" class="headerlink" title="bind、call、apply 区别？如何实现一个bind?"></a>bind、call、apply 区别？如何实现一个bind?</h1><ul>
<li><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p>
</li>
<li><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组</p>
</li>
<li><p>call和apply他们的返回结果是直接执行的，bind的返回结果是待执行函数</p>
</li>
<li><p><code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 <code>bind</code> 实现柯里化       柯里化技术，<strong>主要体现在函数里面返回函数</strong>。</p>
<p><strong>实现<code>bind</code>的步骤，我们可以分解成为三部分：</strong></p>
<ul>
<li><p>修改<code>this</code>指向</p>
<p>动态传递参数</p>
</li>
<li><p>兼容<code>new</code>关键字</p>
</li>
</ul>
</li>
</ul>
<h1 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h1><p>首先，<code>JavaScript</code>是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p>
<p>在<code>JavaScript</code>中，所有的任务都可以分为</p>
<ul>
<li><p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</p>
</li>
<li><p>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</p>
<p>同步任务进入主线程，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环</p>
<p><strong>异步任务还可以细分为微任务与宏任务</strong></p>
</li>
</ul>
<h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为<a class="link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83&spm=1001.2101.3001.7020" >回调<i class="fas fa-external-link-alt"></i></a>事件。</p>
<p>常见的微任务有：</p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>
</ul>
<h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>当前调用栈中执行的代码成为宏任务。</p>
<p>常见的宏任务有：</p>
<ul>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout&#x2F;setInterval</li>
<li>UI rendering&#x2F;UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I&#x2F;O（Node.js）</li>
</ul>
<h1 id="DOM常见的操作有哪些"><a href="#DOM常见的操作有哪些" class="headerlink" title="DOM常见的操作有哪些"></a>DOM常见的操作有哪些</h1><p><strong>1.查找节点. 2.新建节点. 3.添加新节点. 4.删除节点. 5.设置样式</strong>. </p>
<p>创建节点：document.createElement(“元素名”)</p>
<p>删除节点：parentNode.removeChild(existingChild)删除已有的子节点，返回值为删除节点</p>
<p>修改节点：parentNode.replaceChild(newChild,existingChild)用新节点替换父节点中已有的子节点</p>
<p>查找节点：document.getElementByid(“id属性值”) 返回拥有指定id的第一个对象的引用</p>
<p>设置样式,ele.style.styleName &#x3D; styleValue</p>
<h1 id="说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>说说你对BOM的理解，常见的BOM对象你了解哪些？</h1><p><code>BOM</code> (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</p>
<p>其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率</p>
<p>浏览器的全部内容可以看成<code>DOM</code>，整个浏览器可以看成<code>BOM</code>。</p>
<p>常见的BOM对象有</p>
<p>1、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；</p>
<p>2、document对象，文档对象；</p>
<p>3、location对象，浏览器当前URL信息；</p>
<p>4、navigator对象，浏览器本身信息；</p>
<p>5、screen对象，客户端屏幕信息；</p>
<p>6、history对象，浏览器访问历史信息；</p>
<h1 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h1><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p>
<ul>
<li>cookie</li>
<li>sessionStorage</li>
<li>localStorage</li>
<li>indexedDB</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p><code>Cookie</code>，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 <code>HTTP</code>无状态导致的问题</p>
<p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 <code>cookie</code>有效期、安全性、使用范围的可选属性组成</p>
<p>但是<code>cookie</code>在每次请求中都会被发送，如果不使用 <code>HTTPS</code>并对其加密，其保存的信息很容易被窃取，导致安全风险。</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p><code>HTML5</code>新方法</p>
<ul>
<li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li>
<li>存储的信息在同一域中是共享的</li>
<li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li>
<li>大小：5M（跟浏览器厂商有关系）</li>
<li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li>
<li>受同源策略的限制</li>
</ul>
<p>下面再看看关于<code>localStorage</code>的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;username&#x27;,&#x27;cfangxu&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(&#x27;username&#x27;)	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(&#x27;username&#x27;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure>

<p><code>localStorage</code> 也不是完美的，它有两个缺点：</p>
<ul>
<li>无法像<code>Cookie</code>一样设置过期时间</li>
<li>只能存入字符串，无法直接存对象</li>
</ul>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code>和 <code>localStorage</code>使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，<code>sessionStorage</code> 将会删除数据</p>
<p>**indexedDB **用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用索引来实现对该数据的高性能搜索</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</p>
<ul>
<li>存储大小：<code>cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li>
<li>有效时间：<code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>数据与服务器之间的交互方式，<code>cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：</p>
<ul>
<li>标记用户与跟踪用户行为的情况，推荐使用<code>cookie</code></li>
<li>适合长期保存在本地的数据（令牌），推荐使用<code>localStorage</code></li>
<li>敏感账号一次性登录，推荐使用<code>sessionStorage</code></li>
<li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用<code>indexedDB</code></li>
</ul>
<h1 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h1><ul>
<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>
<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>
</ul>
<p>一个经典的比喻:</p>
<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>
<p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为15秒，不考虑容量限制</p>
<p>电梯第一个人进来后，15秒后准时运送一次，这是节流</p>
<p>电梯第一个人进来后，等待15秒。如果过	程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖</p>
<h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><p>相同点：</p>
<ul>
<li>都可以通过使用 <code>setTimeout</code> 实现</li>
<li>目的都是，降低回调执行频率。节省计算资源</li>
</ul>
<p>不同点：</p>
<ul>
<li>函数防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout</code>和 <code>setTimeout</code>实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能</li>
<li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次</li>
</ul>
<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<p>节流在间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
<h1 id="如何通过JS判断一个数组"><a href="#如何通过JS判断一个数组" class="headerlink" title="如何通过JS判断一个数组"></a>如何通过JS判断一个数组</h1><p><code>instanceof</code>方法		</p>
<ul>
<li><code>instanceof</code> 运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li>
</ul>
<p><code>constructor</code>方法</p>
<ul>
<li><code>constructor</code>属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr.constructor == Array; //true</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ES5</code>新增方法<code>isArray()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Array(123);</span><br><span class="line">var b = new Date();</span><br><span class="line">console.log(Array.isArray(a)); //true</span><br><span class="line">console.log(Array.isArray(b)); //false</span><br></pre></td></tr></table></figure>

<h1 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h1><ul>
<li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的</li>
<li>简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li>
</ul>
<h1 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h1><ul>
<li>每个对象都会在其内部初始化一个属性，就是<code>__proto__</code>，当我们访问一个对象的属性时</li>
<li>如果这个对象内部不存在这个属性，那么他就会去<code>__proto__</code>里找这个属性，这个<code>__proto__</code>又会有自己的<code>__proto__</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li>
<li><strong>原型特点：</strong><ul>
<li><code>JavaScript</code>对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li>
</ul>
</li>
</ul>
<h1 id="请解释什么是事件代理"><a href="#请解释什么是事件代理" class="headerlink" title="请解释什么是事件代理"></a>请解释什么是事件代理</h1><ul>
<li>事件代理（<code>Event Delegation</code>），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>
<li>可以大量节省内存占用，减少事件注册，比如在<code>table</code>上代理所有<code>td</code>的<code>click</code>事件就非常棒</li>
<li>可以实现当新增子对象时无需再次对其绑定</li>
</ul>
<h1 id="谈谈This对象的理解"><a href="#谈谈This对象的理解" class="headerlink" title="谈谈This对象的理解"></a>谈谈This对象的理解</h1><ul>
<li><code>this</code>总是指向函数的直接调用者（而非间接调用者）</li>
<li>如果有<code>new</code>关键字，<code>this</code>指向<code>new</code>出来的那个对象</li>
<li>在事件中，<code>this</code>指向触发这个事件的对象</li>
</ul>
<h1 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么"></a>new操作符具体干了什么</h1><ul>
<li>创建一个空对象，并且 <code>this</code> 变量引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到 <code>this</code> 引用的对象中</li>
<li>新创建的对象由 <code>this</code> 所引用，并且最后隐式的返回 <code>this</code></li>
</ul>
<h1 id="null，undefined-的区别"><a href="#null，undefined-的区别" class="headerlink" title="null，undefined 的区别"></a>null，undefined 的区别</h1><ul>
<li><code>undefined</code> 表示不存在这个值。	</li>
<li><code>null</code> 表示一个对象被定义了，值为“空值”</li>
</ul>
<h1 id="javascript-代码中的”use-strict”-是什么意思"><a href="#javascript-代码中的”use-strict”-是什么意思" class="headerlink" title="javascript 代码中的”use strict”;是什么意思"></a>javascript 代码中的”use strict”;是什么意思</h1><ul>
<li><code>use strict</code>是一种<code>ECMAscript 5</code> 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<h1 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h1><ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<h1 id="谈一谈箭头函数与普通函数的区别"><a href="#谈一谈箭头函数与普通函数的区别" class="headerlink" title="谈一谈箭头函数与普通函数的区别"></a>谈一谈箭头函数与普通函数的区别</h1><p>1：定义语法的格式不一样 普通函数用function  箭头函数用箭头声明</p>
<p>2：普通函数可以用作构造函数，可以调用new，有原型， 箭头函数都不可以 </p>
<p>3：普通函数有arguments（参数a g有 们 是） ， 箭头函数没有，但是可以调用外围的arguments对象  arguments是给函数传入参数的时候可以像数组一样调用数组的元素或属性	</p>
<p>4：普通函数的this是动态的， 箭头函数中的this一般指向全局对象window 如果被普通函数包含，就指向上一层</p>
<p>5：普通函数可以通过call ，apply，bind方法改变this的指向， 箭头函数不能</p>
<h1 id="JS中的数组的方法"><a href="#JS中的数组的方法" class="headerlink" title="JS中的数组的方法"></a>JS中的数组的方法</h1><p>pop     push     shift     unshift0</p>
<p>join </p>
<p>array    array.fill       array.from</p>
<p>splice    indexOf   includes</p>
<p>sort  reverse </p>
<p>find   findIndex</p>
<p>toString</p>
<h1 id="JS-数组和对象的遍历方式，以及几种方式的比较"><a href="#JS-数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="JS 数组和对象的遍历方式，以及几种方式的比较"></a>JS 数组和对象的遍历方式，以及几种方式的比较</h1><ol>
<li>for in循环</li>
<li>forEach   forEach 无法遍历对象  无法使用break,continue来跳出循环，可以使用return，没有返回值</li>
<li>map  不会对一个空数组进行检测   map方法有返回值，可以return出来，仅用于对数组的循环 </li>
<li>filter</li>
</ol>
<h1 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h1><p>跨域问题如何产生：</p>
<p>浏览器有一个安全机制，叫同源策略，就是指协议域名端口都一致 当一个请求url的协议，域名，端口任意一个与当前页面url不一致，为跨域</p>
<p>nginx代理跨域</p>
<p>node.js中间件代理跨域</p>
<p>后端添加安全域名</p>
<h1 id="XML和JSON的区别"><a href="#XML和JSON的区别" class="headerlink" title="XML和JSON的区别"></a>XML和JSON的区别</h1><ul>
<li>数据体积方面<ul>
<li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li>
</ul>
</li>
<li>数据交互方面<ul>
<li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li>
</ul>
</li>
<li>数据描述方面<ul>
<li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li>
</ul>
</li>
<li>传输速度方面<ul>
<li><code>JSON</code>的速度要远远快于<code>XML</code></li>
</ul>
</li>
</ul>
<h1 id="谈谈你对webpack的看法"><a href="#谈谈你对webpack的看法" class="headerlink" title="谈谈你对webpack的看法"></a>谈谈你对webpack的看法</h1><ul>
<li><code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包<code>Web</code>开发中所用到的<code>HTML</code>、<code>Javascript</code>、<code>CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用</li>
</ul>
<h1 id="webpack的打包原理"><a href="#webpack的打包原理" class="headerlink" title="webpack的打包原理*"></a>webpack的打包原理*</h1><p>webpack中每个模块有一个唯一的id，是从0开始递增的。整个打包后的bundle.js是一个匿名函数自执行。参数则为一个数组。数组的每一项都为个function。function的内容则为每个模块的内容，并按照require的顺序排列<br>我们看到_webpack_require是模块加载函数，接收模块id（对，webpack中每个模块都会有一个独一无二的id，其实也就是在IIFE传参数组中的索引值（0，1，2…）<br>a依赖b，所以在a中调用webpack加载模块的函数</p>
<h1 id="如何优化webpack打包速度"><a href="#如何优化webpack打包速度" class="headerlink" title="如何优化webpack打包速度*"></a>如何优化webpack打包速度*</h1><p>在<code>package.json</code>中的<code>dev</code>配置的时候，配置加上<code>--hot</code>即可</p>
<p>使用fast-sass-loader代替sass-loader</p>
<p>提取公共代码</p>
<h1 id="说说webpack中常见的Loader？解决了什么问题？"><a href="#说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="说说webpack中常见的Loader？解决了什么问题？*"></a>说说webpack中常见的Loader？解决了什么问题？*</h1><p><code>loader</code> 用于对模块的”源代码”进行转换，在 <code>import</code> 或”加载”模块时预处理文件</p>
<p>关于配置<code>loader</code>的方式有三种：</p>
<ul>
<li>配置方式（推荐）：在 webpack.config.js文件中指定 loader</li>
<li>内联方式：在每个 import 语句中显式指定 loader</li>
<li>CLI 方式：在 shell 命令中指定它们</li>
</ul>
<h1 id="说说webpack中常见的Plugin？解决了什么问题？"><a href="#说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="说说webpack中常见的Plugin？解决了什么问题？ *"></a>说说webpack中常见的Plugin？解决了什么问题？ *</h1><p><code>plugin</code>赋予其各种灵活的功能，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期），目的在于解决<code>loader</code> 无法实现的其他事</p>
<p><strong>配置方式</strong>：一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象</p>
<p>Promise对象的then方法用来接收处理成功时响应的数据，catch方法用来接收处理失败时相应的数据。</p>
<h1 id="说说你对promise的了解"><a href="#说说你对promise的了解" class="headerlink" title="说说你对promise的了解"></a>说说你对promise的了解</h1><p>可以把Promise看做一个容器，里边存放了异步操作，主要解决了回调地狱的问题，</p>
<p>promise构造函数接收一个函数作为参数，该函数的两个参数为resolve,reject。异步任务执行成功时调用resolve函数返回结果，执行失败调用reject</p>
<p>Promise对象的then方法用来接收处理成功时响应的数据，catch方法用来接收处理失败时相应的数据。</p>
<h1 id="async函数是什么，有什么作用。"><a href="#async函数是什么，有什么作用。" class="headerlink" title="async函数是什么，有什么作用。"></a>async函数是什么，有什么作用。</h1><p><code>async/await</code>从字面意思上很好理解，<code>async</code>是异步的意思，await有等待的意思，而两者的用法上也是如此。</p>
<p><code>async</code>用于申明一个<code>function</code>是异步的，而<code>await</code> 用于等待一个异步方法执行完成。</p>
<p><code>async</code> 表示这是一个 <code>async</code> 函数，而 <code>await</code> 只能在这个函数里面使用。</p>
<p>*<em>async、await 优缺点</em></p>
<blockquote>
<p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p>
</blockquote>
<h2 id="async-x2F-await和promise的区别"><a href="#async-x2F-await和promise的区别" class="headerlink" title="async&#x2F;await和promise的区别"></a>async&#x2F;await和promise的区别</h2><p><code>Promise</code>最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了，但是如果业务场景是这样呢？我们先调起promise1，然后根据返回值，调用promise2，之后再根据这两个Promises得值，调取promise3。  这样的话代码非常不直观，会有很多嵌套，显得臃肿</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const req = () =&gt; &#123;</span><br><span class="line">    return promise1()</span><br><span class="line">        .then(value1 =&gt; &#123;</span><br><span class="line">            // do something</span><br><span class="line">            return promise2(value1)</span><br><span class="line">                .then(value2 =&gt; &#123;</span><br><span class="line">                    // do something          </span><br><span class="line">                    return promise3(value1, value2)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在相同的业务场景下，async&#x2F;await的好处就来了，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const req = async () =&gt; &#123;</span><br><span class="line">    const value1 = await promise1()</span><br><span class="line">    const value2 = await promise2(value1)</span><br><span class="line">    return promise3(value1, value2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有使用过vue吗？说说你对vue的理解"><a href="#有使用过vue吗？说说你对vue的理解" class="headerlink" title="有使用过vue吗？说说你对vue的理解"></a>有使用过vue吗？说说你对vue的理解</h1><p>是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架</p>
<p>它提供了 <a class="link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVVM&spm=1001.2101.3001.7020" >MVVM<i class="fas fa-external-link-alt"></i></a>数据绑定</p>
<p>MVVM表示的是 Model-View-ViewModel<br>Model：模型层，负责处理业务逻辑以及和服务器端进行交互<br>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面			<br>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁<br><strong>Vue核心特性</strong>，数据驱动（MVVM)，组件化，在Vue中每一个.vue文件都可以视为一个组件，降低整个系统的耦合度，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，</p>
<p>vue提供了钩子函数，在不同的生命周期来执行不同的钩子函数，然后可以在钩子函数内写业务逻辑来实现我们的需求，</p>
<p>vue小比较轻，适合做一些小而快的项目</p>
<h1 id="你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h1><p>翻译过来就是单页应用，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验</p>
<p>我们熟知的JS框架如<code>react</code>,<code>vue</code>,<code>angular</code>,<code>ember</code>都属于<code>SPA</code></p>
<h2 id="SPA和MPA的区别"><a href="#SPA和MPA的区别" class="headerlink" title="SPA和MPA的区别"></a>SPA和MPA的区别</h2><p>MPA翻译过来就是多页应用，在<code>MPA</code>中每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载<code>html</code>、<code>css</code>、<code>js</code>文件</p>
<h4 id="单页应用与多页应用的区别"><a href="#单页应用与多页应用的区别" class="headerlink" title="单页应用与多页应用的区别"></a>单页应用与多页应用的区别</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">单页面应用（SPA）</th>
<th align="left">多页面应用（MPA）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">组成</td>
<td align="left">一个主页面和多个页面片段</td>
<td align="left">多个主页面</td>
</tr>
<tr>
<td align="left">刷新方式</td>
<td align="left">局部刷新</td>
<td align="left">整页刷新</td>
</tr>
<tr>
<td align="left">url模式</td>
<td align="left">哈希模式</td>
<td align="left">历史模式</td>
</tr>
<tr>
<td align="left">SEO搜索引擎优化</td>
<td align="left">难实现，可使用SSR方式改善</td>
<td align="left">容易实现</td>
</tr>
<tr>
<td align="left">数据传递</td>
<td align="left">容易</td>
<td align="left">通过url、cookie、localStorage等传递</td>
</tr>
<tr>
<td align="left">页面切换</td>
<td align="left">速度快，用户体验良好</td>
<td align="left">切换加载资源，速度慢，用户体验差</td>
</tr>
<tr>
<td align="left">维护成本</td>
<td align="left">相对容易</td>
<td align="left">相对复杂</td>
</tr>
</tbody></table>
<h4 id="单页应用优缺点"><a href="#单页应用优缺点" class="headerlink" title="单页应用优缺点"></a>单页应用优缺点</h4><p>优点：</p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面</li>
<li>良好的前后端分离，分工更明确</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于搜索引擎的抓取</li>
<li>首次渲染速度相对较慢</li>
</ul>
<p>实现一个SPA</p>
<p>原理</p>
<ol>
<li>监听地址栏中<code>hash</code>变化驱动界面变化</li>
<li>用<code>pushsate</code>记录浏览器的历史，驱动界面发送变化</li>
</ol>
<h1 id="SPA首屏加载速度慢的怎么解决？"><a href="#SPA首屏加载速度慢的怎么解决？" class="headerlink" title="SPA首屏加载速度慢的怎么解决？"></a>SPA首屏加载速度慢的怎么解决？</h1><p>首屏时间（First Contentful Paint），指的是浏览器从用户输入url地址，到首屏内容渲染完成的时间，</p>
<h2 id="加载慢的原因"><a href="#加载慢的原因" class="headerlink" title="加载慢的原因"></a>加载慢的原因</h2><ul>
<li>网络延时问题</li>
<li>资源文件体积是否过大</li>
<li>资源是否重复发送请求去加载了</li>
<li>加载脚本的时候，渲染内容堵塞了</li>
</ul>
<h2 id="常见的几种SPA首屏优化方式"><a href="#常见的几种SPA首屏优化方式" class="headerlink" title="常见的几种SPA首屏优化方式"></a>常见的几种SPA首屏优化方式</h2><ul>
<li>减小入口文件体积		常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加</li>
<li>静态资源本地缓存         前端合理利用<code>localStorage</code></li>
<li>UI框架按需加载             在日常使用<code>UI</code>框架，例如<code>element-UI</code>、或者<code>antd</code>，我们经常性直接引用整个<code>UI</code>库</li>
<li>图片资源的压缩             对页面上使用到的<code>icon</code>，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻          <code>http</code>请求压力。</li>
<li>组件重复打包</li>
</ul>
<h1 id="VUE路由的原理"><a href="#VUE路由的原理" class="headerlink" title="VUE路由的原理"></a>VUE路由的原理</h1><p>通过改变 URL，在不重新请求页面的情况下，更新页面视图。</p>
<p>更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有<code>2</code>种方式：</p>
<p>1.<strong>Hash</strong> — 利用 URL 中的hash(“#”);</p>
<p>2.利用 <strong>History interface</strong> 在HTML5中新增的方法。</p>
<p>Vue 中，它是通过 <strong>mode</strong> 这一参数控制路由的实现模式：</p>
<h1 id="Vue中组件和插件有什么区别？"><a href="#Vue中组件和插件有什么区别？" class="headerlink" title="Vue中组件和插件有什么区别？"></a>Vue中组件和插件有什么区别？</h1><p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p>
<p>插件通常用来为 <code>Vue</code> 添加全局功能。一般是别人写好的一些东西，可以拿来直接用</p>
<p>两者的区别主要表现在以下几个方面：</p>
<ul>
<li><p>编写形式</p>
<ul>
<li>每一个<code>.vue</code>文件我们都可以看成是一个组件</li>
<li>我们还可以通过<code>template</code>属性来编写一个组件</li>
<li><code>vue</code>插件的实现应该暴露一个 <code>install</code> 方法，第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象</li>
</ul>
</li>
<li><p>注册形式</p>
<ul>
<li>全局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</li>
<li>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</li>
<li>插件的注册通过<code>Vue.use()</code>的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</li>
</ul>
</li>
<li><p>使用场景</p>
</li>
<li><p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code> </p>
<p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p>
<p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p>
</li>
</ul>
<h1 id="Vue组件之间的通信方式都有哪些"><a href="#Vue组件之间的通信方式都有哪些" class="headerlink" title="Vue组件之间的通信方式都有哪些"></a>Vue组件之间的通信方式都有哪些</h1><p>组件间通信的分类可以分成以下</p>
<ul>
<li>父传子<ul>
<li>通过 props 传递</li>
<li>子组件设置<code>props</code>属性，定义接收父组件传递过来的参数</li>
<li>父组件在使用子组件标签中通过字面量来传递值</li>
</ul>
</li>
<li>子传父<ul>
<li>$emit 触发自定义事件</li>
<li>子组件通过<code>$emit触发</code>自定义事件，<code>$emit</code>第二个参数为传递的数值</li>
<li>父组件绑定监听器获取到子组件传递过来的参数</li>
</ul>
</li>
<li>兄弟组件之间的通信<ul>
<li>兄弟组件传值是通过EventBus</li>
<li>创建一个<code>EventBus</code>.js文件，里边主要是到处Vue实例</li>
<li>发送数据组件调用bus.$emit(‘事件名’,传递的数据)</li>
<li>接收数据组件调用bus.$on(“事件名”,回调函数)我们就可以通过回调函数的形参</li>
</ul>
</li>
<li>祖孙与后代组件之间的通信</li>
<li>非关系组件间之间的通信</li>
</ul>
<h1 id="虚拟DOM的理解"><a href="#虚拟DOM的理解" class="headerlink" title="虚拟DOM的理解"></a>虚拟DOM的理解</h1><p><code>Virtual Dom</code>，本质上是以 <code>JavaScript</code> 对象形式存在的对 <code>DOM</code> 的描述</p>
<p>存储在内存中，创建虚拟 <code>DOM</code> 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 <code>DOM</code> 对象的节点与真实 <code>DOM</code> 的属性一一照应</p>
<h1 id="你了解vue的diff算法吗？说说看"><a href="#你了解vue的diff算法吗？说说看" class="headerlink" title="你了解vue的diff算法吗？说说看"></a>你了解vue的diff算法吗？说说看</h1><p>“diff算法就是进行虚拟节点对比,并返回一个patch对象,用来存储两个节点不同的地方,最后用patch记录的消息去局部更新Dom。”</p>
<p>其有两个特点：</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>标签名不同的话，直接删掉，</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p>
<p><code>diff</code>整体策略为：深度优先，同层比较</p>
<h1 id="为什么需要-Virtual-Dom"><a href="#为什么需要-Virtual-Dom" class="headerlink" title="为什么需要 Virtual Dom"></a>为什么需要 Virtual Dom</h1><p>因为要直接操作真实dom的话，每次都会进行页面的刷新，</p>
<p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>dom diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能</p>
<ul>
<li>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘</li>
</ul>
<h1 id="Vue3-0的设计目标是什么？做了哪些优化"><a href="#Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="Vue3.0的设计目标是什么？做了哪些优化"></a>Vue3.0的设计目标是什么？做了哪些优化</h1><p>设计目标：更小更快更友好</p>
<h3 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue3`移除一些不常用的 `API</span><br></pre></td></tr></table></figure>

<p>引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p>
<h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h3><p>主要体现在编译方面：</p>
<ul>
<li>diff算法优化</li>
<li>静态提升</li>
<li>事件监听缓存</li>
<li>SSR优化</li>
</ul>
<h3 id="更友好"><a href="#更友好" class="headerlink" title="更友好"></a>更友好</h3><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力</p>
<h1 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h1><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p>
<ul>
<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>
<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li>
<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li>
<li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>
</ul>
<h1 id="说一下Vue数据响应式的原理"><a href="#说一下Vue数据响应式的原理" class="headerlink" title="说一下Vue数据响应式的原理"></a>说一下Vue数据响应式的原理</h1><p>数据劫持结合发布订阅模式，</p>
<p>首次获取data中的状态，使用es5的object.defineProperty对每一个状态进行getter,setter,</p>
<p>当获取数据时，new一个Dep()对象，该对象中有sub数组，sub数组中是通过watchar收集的依赖，</p>
<p>模板调用状态的地方会生成一个watcher，当修改数据时走setter，通过dep的实例对象调用notify方法，通知观察者watcher，执行update生成新的虚拟DOM树，Vue框架会遍历并对比新虚拟DOM树和旧虚拟DOM树中每个节点的差别，并记录下来，</p>
<h1 id="说说对-React-的理解？有哪些特性？"><a href="#说说对-React-的理解？有哪些特性？" class="headerlink" title="说说对 React 的理解？有哪些特性？"></a>说说对 React 的理解？有哪些特性？</h1><p>React 是一个构建用户界面的javascript库</p>
<ul>
<li>它的核心设计思路有三点，分别是<code>声明式、组件化与 通用性</code>。</li>
<li>声明式的优势在于直观与组合。</li>
<li>组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合。</li>
</ul>
<p>特性有</p>
<p>​	使用类似 HTML 的JSX语法来描述视图	它是JavaScript的语法扩展。，JSX 看起来像HTML，减少学习成本，代码更易读， JSX 并不是 	React 所必须的，但它非常适合 React	</p>
<p>​	通过setState修改数据	react状态可以改变，但不是响应式的，动态改变并没有与视图响应，想要改变并响应视图则需要 setState 修改并更新视图。</p>
<p>​	通过虚拟DOM修改真实DOM  提高性能，避免重复页面刷新</p>
<h1 id="说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h1><p>真实DOM就是我们在浏览器开发者工具中看到的DOM结构</p>
<p>虚拟DOM简单来说就是 JS 对象，此对象中的字段包含了对真实DOM的描述:</p>
<p>解决了频繁操作真实 DOM 的低效率工作-不直接操作 DOM，也在一定程度上提升了性能</p>
<p>更改真实dom要全部修改，会导致回流和重绘， 虚拟dom会进行局部刷新，修改某一个地方</p>
<p>如果直接操作真实dom浏览器会重新加载，</p>
<h1 id="说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h1><p>生命周期是一个事务从诞生到销毁的过程，</p>
<p>在react中生命周期分为三个部分 挂载，更新，卸载</p>
<p>挂载阶段：componentWillMount ，componentDidMount</p>
<p>更新阶段：componentWillUpdate和componentDidUpdate</p>
<p>卸载阶段：componentWillUnmount</p>
<h1 id="说说-React中的setState执行机制"><a href="#说说-React中的setState执行机制" class="headerlink" title="说说 React中的setState执行机制"></a>说说 React中的setState执行机制</h1><p>当需要修改state的状态需要通过调用<code>setState</code>来改变，从而达到更新组件内部数据的作用</p>
<ul>
<li>在组件生命周期或React合成事件中，setState是异步</li>
<li>在异步环境中是同步的，setTimeout或者原生dom事件中，setState是同步</li>
</ul>
<h1 id="说说对React中类组件和函数组件的理解？有什么区别？"><a href="#说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="说说对React中类组件和函数组件的理解？有什么区别？"></a>说说对React中类组件和函数组件的理解？有什么区别？</h1><p>类组件是通过类的编写形式去编写组件，该类必须继承与react.Component，如果要访问父组件传递过来的参数，可以通过this.props的方式去访问，在组件中必须实现render方法， 在return中返回react对象，</p>
<p>函数组件就是通过函数编写形式去编写组件，是react中定义组件最简单的方式，函数的第一个参数为props用于接收父组件传递的参数，</p>
<p>区别:</p>
<p>1:接收父组件传递参数的方式不一样，函数组件是通过第一个参数，类组件是通过this.props()</p>
<p>2:状态管理，函数组件是无状态组件，没有state，但是可以通过hooks来添加react特性，类组件中有state</p>
<p>3:生命周期，在函数组件中，不存在生命周期，因为生命周期钩子都是继承于react.Component,所以，要用到生命周期之只能使用类组件，</p>
<p>4:调用方式，函数组件就直接调用函数，类组件需要将组件实例化，然后调用实例对象的render方法，</p>
<p>总结：函数组件语法更短，更简单，这样更容易开发，理解，如果是简单的需求就使用函数组件，</p>
<p>类组件有react的特性以及生命周期方法，更适合与开发 逻辑比较复杂的项目</p>
<h1 id="说说对React-Hooks的理解？解决了什么问题？"><a href="#说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="说说对React Hooks的理解？解决了什么问题？"></a>说说对React Hooks的理解？解决了什么问题？</h1><p><code>Hook</code> 。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性</p>
<p>Hook可以让函数组件变成有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理</p>
<p>最常见的<code>hooks</code>有如下：</p>
<ul>
<li>useState        声明变量</li>
<li>useEffect       写一些事件</li>
</ul>
<p>在组件通信过程中可以使用<code>useContext</code>，<code>refs</code>学习中我们也用到了<code>useRef</code>获取<code>DOM</code>结构……</p>
<h1 id="说说你对Redux的理解？其工作原理？"><a href="#说说你对Redux的理解？其工作原理？" class="headerlink" title="说说你对Redux的理解？其工作原理？"></a>说说你对Redux的理解？其工作原理？</h1><p><code>React</code>是用于构建用户界面的，帮助我们解决渲染<code>DOM</code>的过程</p>
<p>而在整个应用中会存在很多个组件，每个组件的<code>state</code>是由自身进行管理，包括组件定义自身的<code>state</code>、组件之间的通信通过<code>props</code>传递、使用<code>Context</code>实现数据共享，如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后续维护阶段，我们将花费大量精力去查询状态的变化过程</p>
<p>这种情况下，我们就可以使用redux对所有的状态进行集中管理，相当于一个仓库，</p>
<p>工作原理：</p>
<p><code>redux</code>要求我们把数据都放在 <code>store</code>公共存储空间</p>
<p>一个组件改变了 <code>store</code> 里的数据内容，其他组件就能感知到 <code>store</code>的变化，再来取数据，从而间接的实现了这些数据传递的功能</p>
<h1 id="说说-React-性能优化的手段有哪些"><a href="#说说-React-性能优化的手段有哪些" class="headerlink" title="说说 React 性能优化的手段有哪些"></a>说说 React 性能优化的手段有哪些</h1><p><code>React</code>凭借<code>virtual DOM</code>和<code>diff</code>算法拥有高效的性能，</p>
<p>除此之外， 常见性能优化常见的手段有如下：</p>
<ul>
<li><p>避免使用内联函数</p>
</li>
<li><p>使用 React Fragments 避免额外标记</p>
</li>
<li><p>使用 Immutable</p>
</li>
<li><p>懒加载组件</p>
</li>
<li><p>事件绑定方式</p>
</li>
<li><p>服务端渲染</p>
<h1 id="vue、react、angular-区别"><a href="#vue、react、angular-区别" class="headerlink" title="vue、react、angular 区别"></a>vue、react、angular 区别</h1><ul>
<li><code>Vue.js</code> 一个用于创建 <code>web</code> 交互界面的库，是一个精简的 <code>MVVM</code>。它通过双向数据绑定把 <code>View</code> 层和 <code>Model</code> 层连接了起来。实际的 <code>DOM</code> 封装和输出格式都被抽象为了<code>Directives</code> 和 <code>Filters</code></li>
<li><code>AngularJS</code> 是一个比较完善的前端<code>MVVM</code>框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 <code>Angular</code>指令</li>
<li><code>react</code> <code>React</code> 仅仅是 <code>VIEW</code> 层是<code>facebook</code>公司。推出的一个用于构建<code>UI</code>的一个库，能够实现服务器端的渲染。用了<code>virtual dom</code>，所以性能很好</li>
</ul>
</li>
</ul>
<h1 id="说说你对-TypeScript-的理解？与-JavaScript-的区别"><a href="#说说你对-TypeScript-的理解？与-JavaScript-的区别" class="headerlink" title="说说你对 TypeScript 的理解？与 JavaScript 的区别"></a>说说你对 TypeScript 的理解？与 JavaScript 的区别</h1><ul>
<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>
</ul>
<h1 id="说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中泛型的理解？应用场景？"></a>说说你对 TypeScript 中泛型的理解？应用场景？</h1><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型</p>
<p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p>
<ul>
<li>函数</li>
<li>接口</li>
<li>类</li>
</ul>
<h1 id="说说你对微信小程序的理解？优缺点？"><a href="#说说你对微信小程序的理解？优缺点？" class="headerlink" title="说说你对微信小程序的理解？优缺点？"></a>说说你对微信小程序的理解？优缺点？</h1><p>2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务</p>
<p>小程序是一种不需要下载安装即可使用的应用，</p>
<p>优点：</p>
<ul>
<li>随搜随用，用的时候只需要搜索或扫一下就可以使用：使得小程序可以代替许多APP，</li>
<li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li>
<li>安全,开发门槛低</li>
</ul>
<p>缺点：</p>
<ul>
<li>用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li>
<li>体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li>
<li>受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li>
</ul>
<h1 id="说说你对发布订阅、观察者模式的理解？区别？"><a href="#说说你对发布订阅、观察者模式的理解？区别？" class="headerlink" title="说说你对发布订阅、观察者模式的理解？区别？"></a>说说你对发布订阅、观察者模式的理解？区别？</h1><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>
<p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p>
<p>发布订阅模式</p>
<p>发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责</p>
<p>区别</p>
<p>观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列</p>
<p>在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p>
<h1 id="项目做过哪些性能优化"><a href="#项目做过哪些性能优化" class="headerlink" title="项目做过哪些性能优化"></a>项目做过哪些性能优化</h1><ul>
<li>减少 <code>HTTP</code> 请求数	</li>
<li>避免重定向</li>
<li>图片懒加载</li>
<li>减少<code>DOM</code> 操作 和减少dom元素数量</li>
<li>使用外部 <code>JavaScript</code> 和 <code>CSS</code></li>
<li>避免图片 <code>src</code> 为空</li>
<li>把<code>JavaScript</code>放在页面底部</li>
<li>写公共样式，把一些常用的样式写到公共样式</li>
</ul>
<h1 id="描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="描述浏览器的渲染过程，DOM树和渲染树的区别"></a>描述浏览器的渲染过程，DOM树和渲染树的区别</h1><ul>
<li>浏览器的渲染过程：<ul>
<li>解析<code>HTML</code>构建 <code>DOM</code>(DOM树)，并行请求 <code>css/image/js</code></li>
<li><code>CSS</code> 文件下载完成，开始构建 <code>CSSOM</code>(<code>CSS</code>树)</li>
<li><code>CSSOM</code> 构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li>
<li>布局(<code>Layout</code>)：计算出每个节点在屏幕中的位置</li>
<li>显示(<code>Painting</code>)：通过显卡把页面画到屏幕上</li>
</ul>
</li>
<li><code>DOM</code>树 和 渲染树 的区别：<ul>
<li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li>
<li>渲染树不包括<code>head</code>和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的<code>css</code>属性</li>
</ul>
</li>
</ul>
<h1 id="你认为什么样的前端代码是好的"><a href="#你认为什么样的前端代码是好的" class="headerlink" title="你认为什么样的前端代码是好的"></a>你认为什么样的前端代码是好的</h1><p>好看和好用，</p>
<p>好看就是代码可读性好，容易理解，起码注释清楚，别人接收之后上手也快，即使出现错误也好定位，还有就是规范，代码规范，命名规范，注释规范，等等，</p>
<p>好用就是 高内聚低耦合，把功能相关的模块放到一起，模块与模块之间的依赖降低，复用率一定要高，</p>
<p>我认为符合以上的两点的前端代码才是好的</p>
<h1 id="从浏览器地址栏输入u-rl到显示页面的步骤"><a href="#从浏览器地址栏输入u-rl到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入u  rl到显示页面的步骤"></a>从浏览器地址栏输入u  rl到显示页面的步骤</h1><ul>
<li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li>
<li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，&#x2F;建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li>
<li>载入解析到的资源文件，渲染页面，完成。</li>
</ul>
<h1 id="http-请求报文响应报文的格式"><a href="#http-请求报文响应报文的格式" class="headerlink" title="http 请求报文响应报文的格式"></a>http 请求报文响应报文的格式</h1><h3 id="HTTP报文的组成部分有请求报文和响应报文"><a href="#HTTP报文的组成部分有请求报文和响应报文" class="headerlink" title="HTTP报文的组成部分有请求报文和响应报文"></a>HTTP报文的组成部分有请求报文和响应报文</h3><p>请求报文有请求行，请求头，空行和请求体，</p>
<p>请求行包括请求方法（get,post），请求头是一大堆键值对，空行是指当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体，请求体就是数据部分</p>
<p>响应报文有状态行，响应头，空行和响应体，</p>
<p>状态行包括状态码，以及状态描述等，</p>
<h1 id="Token-cookie-session-区别"><a href="#Token-cookie-session-区别" class="headerlink" title="Token cookie session 区别"></a>Token cookie session 区别</h1><p>首先，http是一个无状态的协议，无状态就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。</p>
<p>cookie和session就是解决无状态的问题，</p>
<p>区别：session存储在服务器，可以理解为一个状态列表，拥有一个标识符sessionid，通常存放cookie中，服务器收到cookie后，解析出sessionid，去session列表中去查找，session依赖与cookie</p>
<p>cookie是一个小型的文本文件，存放在客户端，不太安全，也可以使用https等，来提高它的安全性，</p>
<p>token类似与一个令牌，无状态，用户信息都被加密在token中，服务器收到token后解密就可知道是哪个用户。</p>
<p>JWT就是token的一种实现方式，JWT全称是JSON Web Token。基本可以看出是使用JSON格式传输token</p>
<p>由三部分组成</p>
<p>Header :描述 JWT 的数据。定义了生成签名的算法以及 Token 的类型。Payload（负载）:用来存放实际需要传递的数据。Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成</p>
<h1 id="CORS跨域的原理"><a href="#CORS跨域的原理" class="headerlink" title="CORS跨域的原理"></a>CORS跨域的原理</h1><p><code>CORS</code> 是一种基于 <a class="link"   href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Glossary/Header" >HTTP Header<i class="fas fa-external-link-alt"></i></a> 的机制，该机制通过允许服务器标示除了它自己以外的其它域。服务器端配合浏览器实现 <code>CORS</code> 机制，可以突破浏览器对跨域资源访问的限制，实现跨域资源请求。	</p>
<p><code>CORS</code> 的验证机制分两种模式：简单请求和预检请求。</p>
<p>简单请求模式下浏览器直接发送请求，并在请求头中携带 <code>Origin</code>。 服务器端接到请求后，会根据自己的跨域规则，通过响应头 <code>Access-Control-Allow-Origin</code> 来返回验证结果。</p>
<p>需要预检的请求必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求到服务器，服务器基于预检请求的信息来判断是否接受接下来的实际请求。</p>
<h1 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h1><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel</p>
<p>Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，</p>
<p>数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p>
<p>MVVM表示的是 Model-View-ViewModel<br>Model：模型层，负责处理业务逻辑以及和服务器端进行交互<br>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面			<br>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</p>
<h1 id="说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>说说你对版本管理的理解？常用的版本管理工具有哪些？</h1><ul>
<li>适合多人团队协作开发</li>
<li>代码集中化管理</li>
<li>可以离线工作</li>
<li>每个计算机都是一个完整仓库</li>
</ul>
<p>常用的版本管理工具有Git和HG它可以有效地处理任何规模的项目，并提供简单直观的界面</p>
<h1 id="说说你对Git的理解？"><a href="#说说你对Git的理解？" class="headerlink" title="说说你对Git的理解？"></a>说说你对Git的理解？</h1><p>Git是分布式版本管理工具，可以把代码仓库完整地镜像下来，这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复	</p>
<h1 id="说说Git常用的命令有哪些"><a href="#说说Git常用的命令有哪些" class="headerlink" title="说说Git常用的命令有哪些"></a>说说Git常用的命令有哪些</h1><p><strong>git init</strong>    用于创建一个新的代码库。</p>
<p>通过<code>git clone &lt;项目远程地址&gt;</code>下载下来最新的代码，</p>
<p><strong>git status</strong>	显示所有需要提交的文件。</p>
<p>git add . 	提交全部文件修改到缓存区<br><strong>git diff</strong>	   显示尚未添加到stage的文件的变更</p>
<p>git   log        查看提交历史</p>
<p>git merge   可以将指定分支的历史记录合并到当前分支</p>
<h1 id="说说-git-发生冲突的场景？如何解决？"><a href="#说说-git-发生冲突的场景？如何解决？" class="headerlink" title="说说 git 发生冲突的场景？如何解决？"></a>说说 git 发生冲突的场景？如何解决？</h1><p>多个人对同一个分支进行更改  会发生冲突，</p>
<p>多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称   会产生冲突</p>
<p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>
<h1 id="jsonp的实现原理"><a href="#jsonp的实现原理" class="headerlink" title="jsonp的实现原理"></a>jsonp的实现原理</h1><p>jsonp是一种跨域通信的手段，我们可以使用它来解决跨域问题</p>
<p>1、首先是利用script标签的src属性来实现跨域。<br>2、通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。<br>3、由于使用script标签的src属性，因此只支持get方法</p>
<h1 id="对高阶组件的理解"><a href="#对高阶组件的理解" class="headerlink" title="对高阶组件的理解"></a>对高阶组件的理解</h1><p>高阶组件其实就是一个函数，	这个函数接收一个组件作为输入，返回一个新的组件作为结果，</p>
<p>返回的新组件拥有了输入组件所不具有的一些功能</p>
<p>好处：</p>
<p>重用代码：提取出来逻辑，利用高阶组件的方式应用出去，就可以减少很多组件的重复代码，</p>
<p>修改现有react组件的行为：有些现成react组件并不是开发者自己开发的，来源第三方，希望修改里边的逻辑</p>
<h1 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h1><p><strong>受控组件</strong>简单来说就是受我们控制的组件，组件依赖于状态</p>
<p>例如input框，我们输入之后，内容无法显示出来，我们就可以对input一个onChange事件，在函数内部实现state的更新</p>
<p><strong>非受控组件</strong>就是不受我们控制的组件，不受状态的控制，像以上那种情况，就要使用ref查询DOM查找值，</p>
<p>实际上非受控组件获取数据就是相当于操作DOM</p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>受控组件使用场景： 一般用于需要动态设置其初始值的情况，  例如：某些form表单信息编辑时，input表单元素需要初始显示值时</p>
<p>非受控组件使用场景：一般用于无任何动态初始值信息的情况，例如form表单创建，input没有初始值，需要用户输入的情况，</p>
<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><p>200请求成功</p>
<p>300重定向，</p>
<p>400资源不存在    404没有找到页面， 405 没有权限，常见的就是我们使用网上图片，如果有防盗链的话，就会报出405</p>
<p>500服务器端错误	</p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2018/09/19/promise%E5%92%8Canyac%E5%92%8Cawait/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">promise和async/await介绍</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2018/06/11/vue3%E7%9F%A5%E8%AF%86%E7%82%B9/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Vue3知识点</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Continue Study</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
            <div class="icp-info info-item"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">豫ICP证000000000001</a></div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">说说你对盒子模型的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">标准盒子模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IE-%E6%80%AA%E5%BC%82%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">IE 怪异盒子模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">css选择器有哪些？优先级？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.1.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">继承属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E5%91%A2%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E8%B7%9F%E9%87%8D%E7%BB%98%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">怎么理解回流跟重绘？什么场景下会触发？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">什么是响应式设计？响应式设计的基本原理是什么？如何做？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">5.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">5.2.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8CCSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">如果要做优化，CSS提高性能的方法有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%99%E4%B8%AA%E8%81%8C%E4%BD%8D%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%90%86%E8%A7%A3%E7%9A%84%EF%BC%9F%E5%AE%83%E7%9A%84%E5%89%8D%E6%99%AF%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">7.</span> <span class="nav-text">对前端工程师这个职位是怎么样理解的？它的前景会怎么样?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">说说JavaScript中的数据类型？存储上的差别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">typeof 与 instanceof 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.</span> <span class="nav-text">说说你对闭包的理解？闭包使用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bind%E3%80%81call%E3%80%81apply-%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind"><span class="nav-number">11.</span> <span class="nav-text">bind、call、apply 区别？如何实现一个bind?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">12.</span> <span class="nav-text">说说你对事件循环的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">12.1.</span> <span class="nav-text">宏任务与微任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">12.1.1.</span> <span class="nav-text">微任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">12.1.2.</span> <span class="nav-text">宏任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">13.</span> <span class="nav-text">DOM常见的操作有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84BOM%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">说说你对BOM的理解，常见的BOM对象你了解哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">Javascript本地存储的方式有哪些？区别及应用场景？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie"><span class="nav-number">15.0.1.</span> <span class="nav-text">cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage"><span class="nav-number">15.0.2.</span> <span class="nav-text">localStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sessionStorage"><span class="nav-number">15.0.3.</span> <span class="nav-text">sessionStorage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">15.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">15.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">什么是防抖和节流？有什么区别？如何实现？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="nav-number">16.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">16.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87JS%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">17.</span> <span class="nav-text">如何通过JS判断一个数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">18.</span> <span class="nav-text">说说你对作用域链的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">JavaScript原型，原型链 ? 有什么特点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="nav-number">20.</span> <span class="nav-text">请解释什么是事件代理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">21.</span> <span class="nav-text">谈谈This对象的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">22.</span> <span class="nav-text">new操作符具体干了什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null%EF%BC%8Cundefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">23.</span> <span class="nav-text">null，undefined 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E2%80%9Duse-strict%E2%80%9D-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">24.</span> <span class="nav-text">javascript 代码中的”use strict”;是什么意思</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">25.</span> <span class="nav-text">同步和异步的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">谈一谈箭头函数与普通函数的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">27.</span> <span class="nav-text">JS中的数组的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">28.</span> <span class="nav-text">JS 数组和对象的遍历方式，以及几种方式的比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">29.</span> <span class="nav-text">如何解决跨域问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">30.</span> <span class="nav-text">XML和JSON的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%9C%8B%E6%B3%95"><span class="nav-number">31.</span> <span class="nav-text">谈谈你对webpack的看法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#webpack%E7%9A%84%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86"><span class="nav-number">32.</span> <span class="nav-text">webpack的打包原理*</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96webpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6"><span class="nav-number">33.</span> <span class="nav-text">如何优化webpack打包速度*</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">说说webpack中常见的Loader？解决了什么问题？*</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Plugin%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">说说webpack中常见的Plugin？解决了什么问题？ *</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9promise%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">36.</span> <span class="nav-text">说说你对promise的了解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E3%80%82"><span class="nav-number">37.</span> <span class="nav-text">async函数是什么，有什么作用。</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#async-x2F-await%E5%92%8Cpromise%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">37.1.</span> <span class="nav-text">async&#x2F;await和promise的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87vue%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">38.</span> <span class="nav-text">有使用过vue吗？说说你对vue的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E5%AF%B9SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0SPA%E5%BA%94%E7%94%A8%E5%91%A2"><span class="nav-number">39.</span> <span class="nav-text">你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SPA%E5%92%8CMPA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">39.1.</span> <span class="nav-text">SPA和MPA的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">39.1.0.1.</span> <span class="nav-text">单页应用与多页应用的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">39.1.0.2.</span> <span class="nav-text">单页应用优缺点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">SPA首屏加载速度慢的怎么解决？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">40.1.</span> <span class="nav-text">加载慢的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DSPA%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">40.2.</span> <span class="nav-text">常见的几种SPA首屏优化方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VUE%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">41.</span> <span class="nav-text">VUE路由的原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">Vue中组件和插件有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">43.</span> <span class="nav-text">Vue组件之间的通信方式都有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">44.</span> <span class="nav-text">虚拟DOM的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3vue%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%9C%8B"><span class="nav-number">45.</span> <span class="nav-text">你了解vue的diff算法吗？说说看</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Virtual-Dom"><span class="nav-number">46.</span> <span class="nav-text">为什么需要 Virtual Dom</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="nav-number">47.</span> <span class="nav-text">Vue3.0的设计目标是什么？做了哪些优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%B0%8F"><span class="nav-number">47.0.1.</span> <span class="nav-text">更小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%BF%AB"><span class="nav-number">47.0.2.</span> <span class="nav-text">更快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%8F%8B%E5%A5%BD"><span class="nav-number">47.0.3.</span> <span class="nav-text">更友好</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue3-0-%E6%89%80%E9%87%87%E7%94%A8%E7%9A%84-Composition-Api-%E4%B8%8E-Vue2-x-%E4%BD%BF%E7%94%A8%E7%9A%84-Options-Api-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BVue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">49.</span> <span class="nav-text">说一下Vue数据响应式的原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-React-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">说说对 React 的理解？有哪些特性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-Real-DOM-%E5%92%8C-Virtual-DOM-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">说说 Real DOM 和 Virtual DOM 的区别？优缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%EF%BC%9F%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-React%E4%B8%AD%E7%9A%84setState%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">53.</span> <span class="nav-text">说说 React中的setState执行机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9React%E4%B8%AD%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">54.</span> <span class="nav-text">说说对React中类组件和函数组件的理解？有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9React-Hooks%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">55.</span> <span class="nav-text">说说对React Hooks的理解？解决了什么问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Redux%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">说说你对Redux的理解？其工作原理？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">57.</span> <span class="nav-text">说说 React 性能优化的手段有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue%E3%80%81react%E3%80%81angular-%E5%8C%BA%E5%88%AB"><span class="nav-number">58.</span> <span class="nav-text">vue、react、angular 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%B8%8E-JavaScript-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">59.</span> <span class="nav-text">说说你对 TypeScript 的理解？与 JavaScript 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">说说你对 TypeScript 中泛型的理解？应用场景？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">61.</span> <span class="nav-text">说说你对微信小程序的理解？优缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">62.</span> <span class="nav-text">说说你对发布订阅、观察者模式的理解？区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">63.</span> <span class="nav-text">项目做过哪些性能优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%8CDOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">64.</span> <span class="nav-text">描述浏览器的渲染过程，DOM树和渲染树的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%A0%E8%AE%A4%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A5%BD%E7%9A%84"><span class="nav-number">65.</span> <span class="nav-text">你认为什么样的前端代码是好的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5u-rl%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">66.</span> <span class="nav-text">从浏览器地址栏输入u  rl到显示页面的步骤</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">67.</span> <span class="nav-text">http 请求报文响应报文的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">67.0.1.</span> <span class="nav-text">HTTP报文的组成部分有请求报文和响应报文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Token-cookie-session-%E5%8C%BA%E5%88%AB"><span class="nav-number">68.</span> <span class="nav-text">Token cookie session 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CORS%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">69.</span> <span class="nav-text">CORS跨域的原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVVM"><span class="nav-number">70.</span> <span class="nav-text">什么是MVVM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">71.</span> <span class="nav-text">说说你对版本管理的理解？常用的版本管理工具有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Git%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">72.</span> <span class="nav-text">说说你对Git的理解？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4Git%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">73.</span> <span class="nav-text">说说Git常用的命令有哪些</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-git-%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">74.</span> <span class="nav-text">说说 git 发生冲突的场景？如何解决？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jsonp%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">75.</span> <span class="nav-text">jsonp的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">76.</span> <span class="nav-text">对高阶组件的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">77.</span> <span class="nav-text">受控组件和非受控组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">77.0.1.</span> <span class="nav-text">应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">78.</span> <span class="nav-text">http状态码</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
