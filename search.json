[{"title":"我的第一篇文章","url":"/2022/04/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"Welcome to 第一篇文章，我在这里记录我创建博客时的问题dir\t查询文件目录hexo serve 启动hexo n “我的第一篇文章”hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写\n参考 bilibiliup (https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click)\nhttps://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click\n部署到github  需要下载hexo-deployer-git需要到_config.yml下的Deployment去配置type&#x3D;”git”和git地址然后就可以进行部署  hexo d \n"},{"title":"Hello World","url":"/2022/04/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Vue3 笔记","url":"/2022/04/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%88%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%EF%BC%89/","content":"1，什么是组合式的API?将相关联的代码保持在了一起，那么我们的代码将更具有可读性，因此也更具有可维护性。\nsetup组件选项setup有两个参数， props  和 context\n1,setup 函数中的第一个参数是 props。setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，(不能直接console.log(props.title)   &#x3D;&gt;&gt;undinfd) ，它会消除 prop 的响应性。 \n所以要使用toRefs\nconst &#123; title &#125; = toRefs(props)console.log(title.value)\n\n2,传递给 setup 函数的第二个参数是 context。context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：\n响应式变量 ref，reactive在 Vue 3.0 中，我们可以通过一个新的 ref 函数使任何响应式变量在任何地方起作用\nvue2选项式API\nvue3组合式API\ntoref()  映射一个方法\ntorefs() 映射全部方法\ntoRefs?\n计算属性和监听属性？计算属性 computed，  监听属性 wathch  watchEffect\n\n\n生命周期函数：主要有三个：\n组件诞生：onMounted（）\n组件更改：onUpdated（）\n组件卸载：onUnmounted（）\n全局属性：在main.js中设置例如设置axios   &#x3D;&gt;&gt;   app.config.globalProperties.http &#x3D; axios \nvue3实例获取：因为vue3中不能用this，所以要使用另一个方法getCurrentInstance  具体用法，下方：\n\n数组赋值：不能直接给数组等于   例如要改变列表的话要使用   tolist.push(…res.data)\n组件传值：父传子：\n子传父：\n兄弟传值：\nprovide  inject 传值方法直接定义，然后取就可以  很简单，不过使用的时候都要导入  \n\n\nvue3中代码复用 Mixin在入口文件main.js中定义即可\n\n过滤器全局过滤器\n注册\n使用\n面试题总结：1，typeof类型判断\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型\n\n如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的\n\nstr instanceof String // false\n## 2，**类型转换**首先我们要知道，在 `JS` 中类型转换只有三种情况，分别是：- 转换为布尔值- 转换为数字- 转换为字符串## **4， == 和 === 有什么区别**对于 `==` 来说，如果对比双方的类型不一样的话，就会进行类型转换对于 `===` 来说，就是判断两者类型和值是否全相同,## 5，**闭包**闭包是可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，创建一个闭包最简单的方法就是在一个函数中创建另一个函数，**闭包存在的意义就是让我们可以间接访问函数内部的变量**另外它有三个特性：1，函数内可以再嵌套函数。2，内部函数可以访问外部的方法和变量。3，方法和变量不会被垃圾回收机制回收。“垃圾回收机制(简称GC), python解释器自带的一种机制 它是一种动态存储管理技术,自动释放不再被程序引用的对象所占用的内存空间”循环中使用闭包解决 `var` 定义函数的问题1. 第三种就是使用 `let` 定义 `i` 了来解决问题了，这个也是最为推荐的方式## **6 ，深浅拷贝**浅拷贝：可以通过 `Object.assign`深拷贝：JSON.parse(JSON.stringify(object))JOSN.parse(JOSN.stringify())浅拷贝 通过 object.assign         会拷贝所有属性到新对象中，如果属性值是对象的话，就拷贝它的地址。深拷贝 通过JSON.parse(JSON.stringify(object))## 7，原型     每个函数都有一个属性 __proto__ 这个就是该函数的原型, 原型链就是多个对象 通过__proto__的方式连接了起来## 8，let  const   var 的区别**var**声明的变量是全局变量，也是顶层变量，存在变量提升的情况，我们可以对一个变量进行多次声明，后面的会覆盖前面的**let**是es6新增的命令，let声明的变量只在所在的代码块有效，不存在变量提升，不允许在同一作用域内重复声明**const**声明一个只读的变量，一旦声明不可改变，# 9,原型继承和class继承原型继承:就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。class继承:`class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，因为这段代码可以看成 `Parent.call(this, value)`。# 10,模块化?模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能- 解决命名冲突- 提供复用性- 提高代码可维护性# 11,**实现一个简洁版的promise**# 12.** Event Loop**## 进程与线程本质上来说，两个名词都是 `CPU` 工作时间片的一个描述。进程描述了 `CPU` 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序线程是进程中的更小单位，描述了执行一段指令所需的时间## 执行栈可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则## 浏览器中的 Event Loop# 14,new因为你使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题# 15,**instanceof 的原理**\ninstanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype\n\n\n\n实现一下 instanceof\n\n首先获取类型的原型\n然后获得对象的原型\n然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null\n\n"}]