[{"title":"JSX语法","url":"/2021/01/20/JSX%E8%AF%AD%E6%B3%95/","content":"JSX 是JavaScript XML的缩写，不是html或xml，基于ECMAScript的一种新特性，一种定义带属性树结构的语法；\n特性：\n\n自定义组件名首字母大写\n嵌套；在render函数中return返回的只能包含一个顶层标签，否则也会报错。\n求值表达式；JSX基本语法规则，遇到HTML标签（以&lt;开头），就用HTML规则解析；遇到代码块（以{开头），就用JS规则解析\n驼峰命名\nclass属性需要写成className\nJSX允许直接在模板插入JS变量。如果这个变量是一个数组，则会展开这个数组的所有成员\n在JSX中插入用户输入是安全的，默认情况下ReactDOM会在渲染前，转义JSX中的任意值，渲染前，所有的值都被转化为字符串形式，这能预防XSS攻击。\n\n","categories":["React"]},{"title":"Es6系列面试题","url":"/2022/05/30/Es6%E7%B3%BB%E5%88%97/","content":"什么是es6？ECMAScript 6（以下简称ES6）\nECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。\nes6补充了es5当中的一些不足，例如在字符串，数组，对象，函数上的变化， \nES6的目标，是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。\n什么是js？JavaScript简称“JS”是一种轻量级的脚本语言，可以部署在多种环境，最常见的部署环境是浏览器。所谓“脚本语言”，指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的操作方法\nes6的模块化？ES6的模块化分为导出（export）与导入（import）两个模块。\n在ES6中每一个模块即是一个文件，在文件中定义的变量，函数，对象在外部是无法获取的。 如果你希望外部可以读取模块当中的内容，就必须使用export来对其进行暴露（输出）\n然后在需要的地方来进行引入\n块级作用域？在 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n所以块级作用域是es6新推出的\n声明的变量只在块级作用域中生效，块级作用域它的作用就是避免全局作用域的\n说说var、let、const之间的区别？用var声明的变量既是全局变量，也是顶层变量,          注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象\n使用var声明的变量存在变量提升的情况,使用var，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明\n在函数中使用使用var声明变量时候，该变量是局部的,      而如果在函数内不使用var，该变量是全局的\nlet是ES6新增的命令，用来声明变量,用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效,不存在变量提升,\n不存在变量提升,如果重复声明的话，就会报错\nconst声明一个只读的常量，一旦声明，常量的值就不能改变，const一旦声明变量，就必须立即初始化，不能留到以后赋值，\nconst实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动\t\nvar、let、const三者区别可以围绕下面五点展开：\n\n变量提升\n暂时性死区\n块级作用域\n重复声明\n修改声明的变量\n使用\n\n变量提升var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined\nlet和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错   \n暂时性死区var不存在暂时性死区\nlet和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量\n块级作用域var不存在块级作用域\nlet和const存在块级作用域\n重复声明var允许重复声明变量\nlet和const在同一作用域不允许重复声明变量\n修改声明的变量var和let可以\nconst声明一个只读的常量。一旦声明，常量的值就不能改变\n使用能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var\n什么是前端工程化？在我的理解上，前端工程化是一种工程化的思想，而并不是一种技术手段。前端工程化的目标就是让前端项目，更利于团队的协作，高内聚，低耦合，提高团队的开发效率。对于后期，更利于前端项目的维护。\n而对于前端项目的维护，我的理解是，项目的结构需要清晰，利于团队的理解，语义应该要明确，因为并不是给个人看的。如何写出健壮的代码也是维护的一个因素。同时，项目应当配有文档，便于使用者理解以及团队的后期维护。\nES6中字符串新增了哪些扩展？模版字符串\n标签模板\nincludes（包含）函数\t    判断字符串中是否含有指定的字符串 ，返回true和false\nES6中数组新增了哪些扩展？扩展运算符，…\nfind()用于找出第一个符合条件的数组成员\nfindIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1\nshift  删除第一个数字\nfill()使用给定值，填充一个数组\nincludes()用于判断数组是否包含给定的值\nES6中对象新增了哪些扩展？super关键字       指向当前对象的原型对象 \n\nObject.is()                   严格判断两个值是否相等\nObject.assign()           用于对象的合并\nObject.setPrototypeOf()            用来设置一个对象的原型对象，        Object.getPrototypeOf()       用于读取一个对象的原型对象\nObject.keys()，Object.values()，Object.entries()\nObject.fromEntries()             用于将一个键值对数组转为对象\n\nES6函数新增了哪些扩展？函数的参数，ES6允许为函数的参数设置默认值\n函数作用域    一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域\n严格模式     只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错\n箭头函数  箭头函数没有this指向，它默认是指向的它父级的this\n你是怎么理解ES6新增Set、Map两种数据结构的？Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构\n\n集合是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合\n字典是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同\n\n区别？\n\n共同点：集合、字典都可以存储不重复的值\n不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储\n\n你是怎么理解ES6中 Promise的？使用场景？Promise的作用主要是解决了回调地狱（回调函数嵌套回调函数）的问题，可以吧promise看作一个容器，里边存放了异步操作，promise接收一个函数作为参数，该函数有两个参数，relove和reject  \n当异步任务执行成功后，会调用relove函数，返回正确响应，当执行失败时会调用reject函数，返回错误响应，\n还有.then  和.catch \n状态promise对象仅有三种状态\n\npending（进行中）\nfulfilled（已成功）\nrejected（已失败）\n\n你是怎么理解ES6中 Generator的？使用场景？Generator 函数是 ES6 提供的一种异步编程解决方案\nGenerator函数是一个普通函数，但是有两个特征：\n\nfunction关键字与函数名之间有一个星号\n\n函数体内部使用yield表达式，定义不同的内部状态\n\npromise和async/await是专门用于处理异步操作的\n\nGenerator并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署Interator接口…）3\n\nasync实质是Generator的语法糖，相当于会自动执行Generator函数\n\n\n你是怎么理解ES6中Proxy的？使用场景?定义： 用于定义基本操作的自定义行为，\nProxy为 构造函数，用来生成 Proxy实例 target表示所要拦截的目标对象       handler通常以函数作为属性的对象\nProxy其功能非常类似于设计模式中的代理模式，常用功能如下：\n\n拦截和监视外部对对象的访问\n降低函数或类的复杂度\n在复杂操作前对操作进行校验或对所需资源进行管理\n\n你是怎么理解ES6中Module的？使用场景？模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的集合\n\n所有代码都运行在模块作用域，不会污染全局作用域\n模块是同步加载的，即只有加载完成，才能执行后面的操作\n\n使用场景\nES6模块化已经深入我们日常项目开发中，像vue、react项目搭建项目，组件化开发处处可见，其也是依赖模块化实现\n你是怎么理解ES6中 Decorator 的？使用场景？Decorator，即装饰器，装饰者模式就是一种在不改变原型和使用继承的情况下，动态地扩展对象功能的设计理论。\n优点\n\n代码可读性变强了，装饰器命名相当于一个注释\n在不改变原有代码情况下，对原来功能进行扩展\n\n","categories":["Es6"]},{"title":"JS面试题总结(基础篇)","url":"/2022/05/04/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E5%9F%BA%E7%A1%80%E7%AF%87)/","content":"面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#56;&#48;&#x31;&#48;&#x30;&#55;&#x37;&#48;&#50;&#54;&#64;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\n闭包闭包就是能够读取其他函数内部变量的函数，\n我们通常用它来定义私有化的变量和方法，创建一个闭包最常见的方法就是在一个函数内创建一个函数，\n闭包的特性：\n\n函数内再嵌套函数\n\n内部函数可以引用外层的参数和变量\n\n参数和变量不会被垃圾回收机制回收\n\n好处：能够实现封装和缓存等；\n\n坏处：就是消耗内存、不正当使用会造成内存溢出的问题\n\n\n使用闭包的注意点\n\n由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露\n解决方法是，在退出函数之前，将不使用的局部变量全部删除\n\n说说你对作用域链的理解作用域链的作用就是保证执行环境里有权访问的变量和函数是有序的，作用域中的变量只能是向上访问的，变量访问到window对象即被终止，作用域链向下访问是不被允许的，\n\n简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\nJavaScript原型，原型链 ? 有什么特点？\n原型：\nJavaScript的所有对象中都包含了一个 [__proto__] 内部属性，这个属性所对应的就是该对象的原型\nJavaScript的函数对象，除了原型 [__proto__] 之外，还预置了 prototype 属性\n当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [__proto__]。\n\n\n原型链：\n当一个对象调用的属性&#x2F;方法自身不存在时，就会去自己 [__proto__] 关联的前辈 prototype 对象上去找\n如果没找到，就会去该 prototype 原型 [__proto__] 关联的前辈 prototype 去找。依次类推，直到找到属性&#x2F;方法或 undefined 为止。从而形成了所谓的“原型链”\n\n\n\n请解释什么是事件代理事件代理又称为事件委托，是javascript中常用的绑定事件技巧，顾名思义，事件代理即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务，事件代理的原理是DOM元素的事件冒泡，使用时间代理的好处就是可以提高性能，\nJavascript如何实现继承？\n构造继承\n\n原型继承\n\n实例继承\n\n拷贝继承\n\n原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式\n\n\n谈谈This对象的理解this总是指向函数的直接调用者，\n如果又new关键字，this就指向new出来的那个对象，\n在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window\n事件模型    *w3c中定义事件的发生经历三个阶段，：捕获阶段，目标阶段，冒泡阶段\n\n冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发\n捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发\nDOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件\n阻止冒泡：在W3c中，使用stopPropagation()方法；在IE下设置cancelBubble = true\n阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3c中，使用preventDefault()方法，在IE下设置window.event.returnValue = false\n\nnew操作符具体干了什么呢?创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型，\n属性和方法被加入到this引用的对象中，\n新创建的对象由this所引用，并且最后隐式的返回this\nAjax原理\nAjax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n\najax 有那些优缺点?\n\n优点：\n通过异步模式，提升了用户体验.\n优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\nAjax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\nAjax可以实现动态不刷新（局部刷新）\n\n\n缺点：\n安全问题 AJAX暴露了与服务器交互的细节。\n对搜索引擎的支持比较弱。\n不容易调试。\n\n\n\n如何解决跨域问题?\n通过jsonp跨域\n\ndocument.domain + iframe跨域\n\nnginx代理跨域\n\nnodejs中间件代理跨域\n\n后端在头部信息里面设置安全域名\n\n\n模块化开发怎么做？首先我们要知道什么是模块化开发?\\1. 模块就是一个有特定功能的文件,我们可以通过加载这些模块得到特定的功能\\2. 模块化开发就是js的功能分离,通过需求引入不同的文件\\3. 模块化开发可以使代码耦合度降低,避免代码多次在页面出现,他最大的作用就是重用\n\n立即执行函数,不暴露私有成员\n\n模块开发要遵循的规范\n\nAMD规范也叫异步模块加载规范,在这个规范下模块会异步加载,不影响后面语句的执行,我们可以使用define定义模块,使用require调用模块\nCommonJS规范是服务器端模块的规范,node.js就采用了这个规范,每个模块都有一个单独的作用域,模块内部的变量无法被其他模块读取,除非定义为global的对象和属性\nCMD规范通用模块定义.CMD是按需加载,一个模块就是一个文件\n\n异步加载JS的方式有哪些？\n设置&lt;script&gt;属性 async&#x3D;”async” （一旦脚本可用，则会异步执行）\n动态创建 script DOM：document.createElement(&#39;script&#39;);\nXmlHttpRequest 脚本注入\n异步加载库 LABjs\n模块加载器 Sea.js\n\n那些操作会造成内存泄漏？\n未使用 var 声明的全局变量\n闭包函数(Closures)\n循环引用(两个对象相互引用)\n控制台日志(console.log)\n移除存在绑定事件的DOM元素(IE)\nsetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收\n\nXML和JSON的区别？\n数据体积方面\nJSON相对于XML来讲，数据的体积小，传递的速度更快些。\n\n\n数据交互方面\nJSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互\n\n\n数据描述方面\nJSON对数据的描述性比XML较差\n\n\n传输速度方面\nJSON的速度要远远快于XML\n\n\n\n谈谈你对webpack的看法\nWebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源\n\n说说你对AMD和Commonjs的理解\nCommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数\nAMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的\n\n常见web安全及防护原理    *\nsql注入原理\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令\n\n\n总的来说有以下几点\n永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等\n永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取\n永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接\n不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息\n\n\n\nXSS原理及防范\n\nXss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点\n\nXSS防范方法\n\n首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击\n\nXSS与CSRF有什么区别吗？\n\nXSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤\n登录受信任网站A，并在本地生成Cookie\n在不登出A的情况下，访问危险网站B\n\nCSRF的防御\n\n服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数\n通过验证码的方法\n\n用过哪些设计模式？  *\n工厂模式：\n工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法\n主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字\n\n\n构造函数模式\n使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于\n直接将属性和方法赋值给 this对象;\n\n\n\n为什么要有同源限制？\n同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\n举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。\n\noffsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight与scrollWidth&#x2F;scrollHeight的区别\noffsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同\nclientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条\nscrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸\n\njavascript有哪些方法定义对象  *\n对象字面量： var obj = &#123;&#125;;\n构造函数： var obj = new Object();\nObject.create(): var obj = Object.create(Object.prototype);\n\n常见兼容性问题？ *\npng24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8\n浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一,，但是全局效率很低，一般是如下这样解决：\n\nbody,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p&#123;margin:0;padding:0;&#125;\n\n\nIE下,event对象有x,y属性,但是没有pageX,pageY属性\nFirefox下,event对象有pageX,pageY属性,但是没有x,y属性.\n\n说说你对promise的了解简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息\n一般 Promise 在执行过程中，必然会处于以下几种状态之一。\n\n待定（pending）：初始状态，既没有被完成，也没有被拒绝。\n已完成（fulfilled）：操作成功完成。\n已拒绝（rejected）：操作失败。\n\n你觉得jQuery源码有哪些写的好的地方*\njquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链\njquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法\n有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度\njquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率\n\nvue、react、angular    *\nVue.js 一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters\nAngularJS 是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令\nreact React 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好\n\nNode的应用场景\n特点：\n1、它是一个Javascript运行环境\n2、依赖于Chrome V8引擎进行代码解释\n3、事件驱动\n4、非阻塞I/O\n5、单进程，单线程\n\n\n优点：\n高并发（最重要的优点）\n\n\n缺点：\n1、只支持单核CPU，不能充分利用CPU\n2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n\n\n\n谈谈你对AMD、CMD的理解\nCommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数\nAMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的\n\n那些操作会造成内存泄漏\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\nsetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\nweb开发中会话跟踪的方法有哪些\ncookie\nsession\nurl重写\n隐藏input\nip地址\n\nJS的基本数据类型和引用数据类型\n基本数据类型：undefined、null、boolean、number、string、symbol\n引用数据类型：object、array、function\n\n介绍js有哪些内置对象\nObject 是 JavaScript 中所有对象的父对象\n数据封装类对象：Object、Array、Boolean、Number 和 String\n其他对象：Function、Arguments、Math、Date、RegExp、Error\n\n说几条写JavaScript的基本规范\n不要在同一行声明多个变量\n请使用===/!==来比较true/false或者数值\n使用对象字面量替代new Array这种形式\n不要使用全局函数\nSwitch语句必须带有default分支\nIf语句必须使用大括号\nfor-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污\n\nJavaScript有几种类型的值\n栈：原始数据类型（Undefined，Null，Boolean，Number、String）\n堆：引用数据类型（对象、数组和函数）\n两种类型的区别是：存储位置不同；\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n在栈中的地址，取得地址后从堆中获得实体\n\njavascript创建对象的几种方式javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用\n\n对象字面量的方式\n用function来模拟无参的构造函数\n用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\n用工厂方式来创建（内置对象）\n用原型方式来创建\n用混合方式来创建\n\neval是做什么的\n它的功能是把对应的字符串解析成JS代码并运行\n应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）\n由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;)\n\nnull，undefined 的区别\nundefined 表示不存在这个值。\n\nnull 表示一个对象被定义了，值为“空值”\n\nnull : 是一个对象(空对象, 没有任何属性和方法)\n\n在验证null时，一定要使用　=== ，因为 ==无法分别null 和　undefined\n\n\n","categories":["js"]},{"title":"JS面试题总结(进阶篇)","url":"/2022/05/03/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E8%BF%9B%E9%98%B6%E7%AF%87)/","content":"面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#56;&#x30;&#49;&#x30;&#48;&#x37;&#x37;&#x30;&#x32;&#54;&#x40;&#49;&#54;&#x33;&#46;&#99;&#111;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\n类型及检测方式JavaScript一共有8种数据类型，7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；\n1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）\nJS数据类型分为两类进行存储：\n基本数据类型：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n引用数据类型：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\nJavaScript 中的数据是如何存储在内存中的？在 JavaScript 中，基本类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\n在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间、堆空间。其中的代码空间主要是存储可执行代码的，原始类型(Number、String、Null、Undefined、Boolean、Symbol、BigInt)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。\n因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在”堆空间”中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。\n数据类型检测（1）typeof\n​\t\t\ttypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n​\t\t\ttypeof对于对象来说，除了函数都会显示object\n，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n2）instanceof\n​\tinstanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype\n数据类型转换首先我们要知道，在 JS 中类型转换只有三种情况，分别是：\n\n转换为布尔值\n转换为数字\n转换为字符串\n\nnull 和 undefined 的区别？ 首先 Undefined 和 Null 都是基本数据类型，\nundefined 代表的含义是未定义， null 代表的含义是空对象\nThisthis总是指向函数的直接调用者，当有new关键字时，this会指向new出来的那个对象，\n函数执行改变this\ncall: fn.call(target, 1, 2)\napply: fn.apply(target, [1, 2])\nbind: fn.bind(target)(1,2)\n\napply&#x2F;call&#x2F;bind 原理变量提升通常提升的解释是说将声明的代码移动到了顶部，\n更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用\n执行上下文当执行 JS 代码时，会产生三种执行上下文\n\n全局执行上下文\n函数执行上下文\neval 执行上下文\n\n\n每个执行上下文中都有三个重要的属性\n\n\n变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问\n作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）\nthis\n\n作用域作用域： 作用域是定义变量的区域，\n作用域可以理解为变量的可访问性，总共分为三种类型，分别为：\n\n全局作用域 &#x3D;&#x3D;&gt;\t全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量\n函数作用域 &#x3D;&#x3D;&gt;     函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域\n块级作用域 &#x3D;&#x3D;&gt;     ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。\n\n作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n闭包闭包其实就是一个可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，创建一个闭包最常见的方法就是在一个函数中创建另一个函数，它有三个特性，1：函数内可以再嵌套函数，2：内部函数可以访问外部的方法和变量，3：方法和变量不会被垃圾回收机制回收，\nNew的原理\n创建一个新对象\n对象连接到构造函数原型上，并绑定 this（this 指向新对象）\n执行构造函数代码（为这个新对象添加属性）\n返回新对象\n\nnew 被调用后大致做了哪几件事情\n让实例可以访问到私有属性；\n让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；\n构造函数返回的最后结果是引用数据类型。\n\n原型&#x2F;原型链原型在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。\n原型链当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，直到找到或undefined，这个就是原型链的概念。\n\n原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__(非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。\n构造函数: 可以通过new来 新建一个对象 的函数。\n实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。\n\njs 获取原型的方法\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n\n继承1，组合继承\t\t组合继承是最常用的继承方式\n2，Class 继承\n面向对象\n基本思想是使用对象，类，继承，封装等基本概念来进行程序设计\n\n优点\n\n易维护\n采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的\n\n\n易扩展\n开发工作的重用性、继承性高，降低重复工作量。\n缩短了开发周期\n\n\n\n一般面向对象包含：继承，封装，多态，抽象\n事件机制事件流有三个阶段\n\n事件捕获阶段\n处于目标阶段\n事件冒泡阶段\n\n事件捕获\n\n事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件\n\n事件冒泡\n\n事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点\n\n无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播\n模块化\njs 中现在比较成熟的有四种模块加载方案：\n\n\n第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。\n第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范\n第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。\n第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块\n\nAMD 和 CMD 规范的区别？第一个方面是在模块定义时对依赖的处理不同，AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。\n第二个方面是对依赖模块的执行时机处理不同，首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，\n谈谈对模块化开发的理解\n我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。\n由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。\n后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。\n现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。\n\nIterator迭代器Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\nIterator 的作用有三个：\n\n创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\nPromise\nPromise 是 ES6 新增的语法，解决了回调地狱的问题。\n\n回调地狱概念：回调函数套回调函数的情况就叫做回调地狱，\n\n可以把 Promise看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。\n\n简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息\n一般 Promise 在执行过程中，必然会处于以下几种状态之一。\n\n待定（pending）：初始状态，既没有被完成，也没有被拒绝。\n已完成（fulfilled）：操作成功完成。\n已拒绝（rejected）：操作失败。\n\nGeneratorGenerator 是 ES6中新增的语法，和 Promise 一样，都可以用来异步编程。Generator 最大的特点就是可以控制函数的执行。\nGenerator函数是ES6提供的一种异步编程解决方案。通过yield标识位和next()方法调用，实现函数的分段执行\nasync&#x2F;awaitGenerator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。\n优缺点：async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。\nasync原理\nasync/await语法糖就是使用Generator函数+自动执行器来运作的\n事件循环\n首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行\n\n在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务\n\n当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行\n\n任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行\n\n当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。\n\n微任务：在 Node.js 中微任务包含 2 种——process.nextTick 和 Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且process.nextTick 和 Promise也存在优先级，process.nextTick 高于 Promise\n\n宏任务\n在 Node.js 中宏任务包含 4 种——setTimeout、setInterval、setImmediate 和 I/O。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列\n\n\n垃圾回收\nJavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。\n\n针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数\n\n\n标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。\n内存泄露意外的全局变量\n定时器\n事件监听:\n闭包\n循环对象引用:\n控制台console.log打印的东西\n深浅拷贝浅拷贝自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象\n但是使用 object.assign 方法有几点需要注意\n\n它不会拷贝对象的继承属性；\n它不会拷贝对象的不可枚举的属性；\n可以拷贝 Symbol 类型的属性。\n\n深拷贝浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。\n深拷贝的原理可以总结如下\n将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。\n节流与防抖\n函数防抖 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n函数节流 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\nProxy代理proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截\nProxy的作用\n\n对于代理模式 Proxy 的作用主要体现在三个方面\n\n\n拦截和监视外部对对象的访问\n降低函数或类的复杂度\n在复杂操作前对操作进行校验或对所需资源进行管理\n\nAjax\nAjax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n\najax 有那些优缺点?\n\n优点：\n通过异步模式，提升了用户体验.\n优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\nAjax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\nAjax可以实现动态不刷新（局部刷新）\n\n\n缺点：\n安全问题 AJAX暴露了与服务器交互的细节。\n对搜索引擎的支持比较弱。\n不容易调试。\n\n\n\n","categories":["js"]},{"title":"Hello World","url":"/2017/05/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"React面试题总结(进阶篇)","url":"/2021/01/19/React%E9%9D%A2%E8%AF%95%E9%A2%98(%E8%BF%9B%E9%98%B6%E7%AF%87)/","content":"面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#56;&#48;&#x31;&#x30;&#48;&#x37;&#x37;&#x30;&#x32;&#54;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\n​\t\n如何避免React生命周期中的坑避免生命周期中的坑需要做好两件事：不在恰当的时候调用了不该调用的代码；在需要调用时，不要忘了调用。\n\ncomponentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。\n\ncomponentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题\n\nshouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化\n\ncomponentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。\n\n如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug\n\n如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加\n\n\n“React 的请求应该放在哪里，为什么?” 这也是经常会被追问的问题。你可以这样回答。\n对于异步请求，应该放在 componentDidMount 中去操作。从时间顺序来看，除了 componentDidMount 还可以有以下选择：\n\nconstructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，并不承载业务逻辑。而且随着类属性的流行，constructor 已经很少使用了\ncomponentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug，不利于未来 React 升级后的代码维护。\n所以React 的请求放在 componentDidMount 里是最好的选择。\n\nReact Fiber架构React Fiber是什么\nReact Fiber是对核心算法的一次重新实现。React Fiber把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会\nReact Fiber改变了之前react的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程\t\n最主要的思想就是将任务拆分。\nReact 追求的是 “快速响应”，那么，“快速响应“的制约因素都有什么呢\n\nCPU的瓶颈：当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿。\nIO的瓶颈：发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。\n\nfiber 架构主要就是用来解决 CPU 和网络的问题，这两个问题一直也是最影响前端开发体验的地方，一个会造成卡顿，一个会造成白屏。为此 react 为前端引入了两个新概念：Time Slicing 时间分片和Suspense。\nReact 都做过哪些优化\n\n调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。\n\n渲染阶段（commit）：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上\n浏览器一帧都会干些什么以及requestIdleCallback的启示\n\n\n我们都知道，页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。目前浏览器大多是 60Hz（60帧&#x2F;s），每一帧耗时也就是在 16.6ms 左右。\n\n接受输入事件\n执行事件回调\n开始一帧\n执行 RAF (RequestAnimationFrame)\n页面布局，样式计算\n绘制渲染\n执行 RIC (RequestIdelCallback)\n\n","categories":["React"]},{"title":"Vue面试题总结","url":"/2018/04/12/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","content":"面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#56;&#48;&#49;&#48;&#48;&#55;&#x37;&#x30;&#50;&#54;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\nVue是什么Vue是一套用于构建用户界面的渐进式框架，所谓渐进式就是Vue只做自己改做的事情，不做职责以外的事，Vue的核心库只关注视图层，\n非常容易与其它库或已有项目整合\nVue响应式原理\nVue 的响应式原理是核心是通过  Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上。\n\n发布订阅模式和观察者模式\n观察者模式是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的\n发布&#x2F;订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在\n\n为什么使用 Virtual DOMVirtual DOM（虚拟DOM），是由普通的 JS 对象来描述DOM对象，因为不是真实的DOM对象，所以叫 Virtual DOM。\n\n手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题。\n虽然有 jQuery 等库简化 DOM 操作并解决了兼容性问题。但是随着项目的复杂，DOM操作复杂提升，既要考虑操作数据，又要考虑操作 DOM。\nVirtual DOM 的好处是，当状态改变时不需要立即更新 DOM，只需要创建一个虚拟 DOM 树来描述 DOM，Virtual DOM 内部将弄清楚如何有效（diff）的更新 DOM。内部使用 diff 算法，找到状态的差异，只更新变化的部分。\n补充1��VDOM 的必要性？\n创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。\n触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。\n\n\n\nVDOM：三个 part\n虚拟节点类，将真实 DOM节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM\n节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象\nre-render：解析 patch 对象，进行 re-render\n\nvue 和 react技术选型相同点：\n\n数据驱动页面，提供响应式的试图组件\n都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范\n数据流动单向，都支持服务器的渲染SSR\n都有支持native的方法，react有React native， vue有wexx\n\n不同点：\n\n数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的\n数据渲染：大规模的数据渲染，react更快\n使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目\n开发风格：react推荐做法jsx + inline style把html和css都写在js了\n\nnextTicknextTick` 可以让我们在下次 `DOM` 更新循环结束之后执行延迟回调，用于获得更新后的 `DOM\n\nnextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用\n\nPromise\nMutationObserver\nsetImmediate\n如果以上都不行则采用setTimeout\n\nVue生命周期首先，我们先来了解一下‘’生命周期‘’这个词\n通俗来讲，生命周期就是一个事务从出生到消失的过程\n在vue中，vue的生命周期是指：从创建vue对象到销毁vue对象的过程，\n钩子函数是Vue框架中内置的一些函数，随着生命周期\t阶段，自动执行，\nbeforeCreate\tcreated\tbeforeMount\tmounted\tbeforeUpdate\tupdated\tbeforeDestroy\tdestroyed\terrorCaptured\nvue-routerVue Router 是 Vue.js 的官方路由，让用 Vue.js 构建单页应用变得轻而易举。\nmode:hash   history\n跳转：\nthis.$router.push()\t\t&lt;router-link to = &#x27; &#x27;&gt;&lt;/router-link&gt;\n\n占位：\n&lt;router-view&gt;&lt;/router-view&gt;\n\nvuexVuex 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化\n核心概念\n\nstate: 状态中心\nmutations: 更改状态\nactions: 异步更改状态\ngetters: 获取状态\nmodules: 将state分成多个modules，便于管理\n\nvue3带来的新特性&#x2F;亮点1. 压缩包体积更小\n​\t当前最小化并被压缩的 Vue 运行时大小约为 20kB（2.6.10 版为 22.8kB）。Vue 3.0捆绑包的大小大约会减少一半，即只有10kB！\n2. Object.defineProperty -&gt; Proxy\n3. Virtual DOM 重构\n细致内容：https://interview2.poetries.top/docs/simply.html#_11-compositon-api\n","categories":["Vue"]},{"title":"怎样理解redux","url":"/2021/01/25/redux%E7%90%86%E8%A7%A3/","content":"React是用于构建用户界面的，帮助我们解决渲染DOM的过程\n而在整个应用中会存在很多个组件，每个组件的state是由自身进行管理，包括组件定义自身的state、组件之间的通信通过props传递、使用Context实现数据共享，如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后续维护阶段，我们将花费大量精力去查询状态的变化过程\n这种情况下，我们就可以使用redux对所有的状态进行集中管理，相当于一个仓库，\n工作原理：\nredux要求我们把数据都放在 store公共存储空间\n一个组件改变了 store 里的数据内容，其他组件就能感知到 store的变化，再来取数据，从而间接的实现了这些数据传递的功能\n","categories":["React"]},{"title":"promise和async/await介绍","url":"/2018/09/19/promise%E5%92%8Canyac%E5%92%8Cawait/","content":"PromisePromise是一个原生对象，是一种异步编程的解决方案，可以替换掉传统的回调函数解决方案，\npromise构造函数接收一个函数作为参数，该函数的两个参数为resolve,reject。异步任务执行成功时调用resolve函数返回结果，执行失败调用reject\nfunction fn(str)&#123;           var p=new Promise(function(resolve,reject)&#123;               //处理异步任务               var flag=true;               setTimeout(function()&#123;                   if(flag)&#123;                       resolve(str)                   &#125;                   else&#123;                       reject(&#x27;操作失败&#x27;)                   &#125;               &#125;)           &#125;)           return p;       &#125;\n\nPromise对象的then方法用来接收处理成功时响应的数据，catch方法用来接收处理失败时相应的数据。\nfn(&#x27;武林要以和为贵&#x27;)    .then((data)=&gt;&#123;        console.log(data);        return fn(&#x27;要讲武德&#x27;);    &#125;)    .then((data)=&gt;&#123;        console.log(data);        return fn(&#x27;不要搞窝里斗&#x27;)    &#125;)    .then((data)=&gt;&#123;        console.log(data);    &#125;)    .catch((data)=&gt;&#123;        console.log(data);    &#125;)\n\n但是Promise最大的问题就是代码冗余，原来的异步任务被Promise封装一下，不管什么操作都用than，就会导致一眼看过去全是than…than…than…,这样也是不利于代码维护的。\n所以下面的async&#x2F;await 可以时代码看起来更像同步代码。\nasync&#x2F;await首先我们看async关键字，他作为一个关键字放到声明函数前面，表示该函数为一个异步任务，不会阻塞后面函数的执行\nasync function fn()&#123;            return &#x27;不讲武德&#x27;;&#125;        console.log(fn());\n\nawait关键字只能在使用async定义的函数中使用\nawait后面可以直接跟一个 Promise实例对象（可以跟任何表达式，更多的是跟一个返回Promise对象的表达式）\nawait可以直接拿到Promise中resolve中的数据。\n总结总结一下，当我们写代码遇到异步回调时，我们想让异步代码按照我们想要的顺序执行，如果按照传统的嵌套方式，就会出现回调地狱，这样的代码不利于维护，我们可以通过Promise对象进行链式编程来解决，这样尽管可以解决问题，但是ES7给我们提供了更加舒适的async&#x2F;await语法糖，可以使得异步代码看起来更像是同步代码。\n","categories":["js"]},{"title":"setState是同步还是异步的？","url":"/2021/01/23/setstate%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5/","content":"它即是同步的又是异步的，根据执行环境不同，\n\nsetState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。\n再简单来说，在异步环境中是同步的，在同步环境中是异步的\nsetState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。\nsetState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。\n\n","categories":["React"]},{"title":"对refs的理解","url":"/2021/01/28/refs/","content":"React 中的 Refs提供了一种方式，允许我们访问 DOM节点或在 render方法中创建的 React元素。\n在某些情况下，我们会通过使用refs来更新组件，但这种方式并不推荐，过多使用refs，会使组件的实例或者是DOM结构暴露，违反组件封装的原则；\n","categories":["React"]},{"title":"State和Props的理解，区别","url":"/2021/01/22/state%E5%92%8Cprops%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"是什么State一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是state，一般在 constructor 中初始化当需要修改里面的值的状态需要通过调用setState来改变，从而达到更新组件内部数据的作用，并且重新调用组件render方法setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成\nProps可以把props理解为从外部传入组件内部的数据react具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据props除了可以传字符串，数字，还可以传递对象，数组甚至是回调函数在子组件中，props在内部不可变的，如果想要改变它看，只能通过外部组件传入新的props来重新渲染子组件，否则子组件的props和展示形式不会改变\n相同点两者都是 JavaScript 对象两者都是用于保存信息props 和 state 都能触发渲染更新\n区别props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化props 在组件内部是不可修改的，但 state 在组件内部可以进行修改state 是多变的、可以修改\n","categories":["React"]},{"title":"vue-router原理","url":"/2021/05/19/vue-router%E5%8E%9F%E7%90%86/","content":"vue-router通过hash与History两种方式实现前端路由，更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式\nVue 中，它是通过 mode 这一参数控制路由的实现模式：\n\nhash:\nhash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新\n通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：      \n\n通过浏览器前进后退改变 URL\n通过&lt;a&gt;标签改变 URL\n通过window.location改变URL\n\nhistory 实现history 提供了 pushState 和 replaceState 两个方法\n","categories":["Vue"]},{"title":"Vue3知识点","url":"/2018/06/11/vue3%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"Vue2响应式原理数据劫持结合发布订阅者模式。\n首次获取data中的状态，使用es5的Object.defineProperty对每一个状态进行getter，setter，当获取数据时，new Dep() 他是一个对象，拥有subs属性是一个数组，用与收集依赖（watcher-观察者）模板调用状态的地方就会生成一个watcher，当修改数据时走setter，通过dep的实例对象调用notify方法，通知观察者watcher，执行update生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来。\n存在问题：​\t1:新增属性，删除属性，界面不会更新​\t2:直接通过下标修改数组，界面不会自动更新\n传统的增加属性    this.person.sex &#x3D; ‘女’解决方案： this.$set(this.person,’sex’,’女’)   这样的话数据会进行响应式处理\n传统的删除属性    delete this.person.name解决方案：\tthis.$delete(this.person,’name’)\n传统的修改属性 \tthis.person.hobby &#x3D; ‘逛街’解决方案\tthis.$update(this.person.hobby,0,’逛街’)\t\nVue3响应式原理实现原理：\n​\t通过Proxy代理：拦截对象中任意属性的变化，包括，属性值的读写，添加，删除等\n​\t通过Reflect反射：对被代理对象的属性进行操作\nVue3的生命周期onBeforeMount,&#x2F;&#x2F; 在组件挂载之前执行的函数  \nonMounted,    \nonBeforeUpdate,&#x2F;&#x2F; 在组件修改之前执行的函数    \nonUpdated,    \nonBeforeUnmount,&#x2F;&#x2F; 在组件卸载之前执行的函数\nVue3中计算属性computed\t如何使用使用前需要先引入\nimport &#123;reactive,computed&#125; from  &#x27;vue&#x27;\n\n使用方式\n//计算属性简写方式(计算属性不可被修改)   obj.fullNum = computed(()=&gt;&#123;       return obj.firstName + &#x27;-&#x27; +obj.lateName   );  //计算属性完整写法（可读写）       obj.fullNum = computed(&#123;            get()&#123;                return obj.firstName + &#x27;-&#x27; + obj.lateName               &#125;,            set(value)&#123;                 const nameArr = value.split(&#x27;-&#x27;)                 obj.firstName = nameArr[0]                 obj.lateName = nameArr[1]               &#125;           &#125;);\n\nVue3中监听属性的使用首先 必须可少的就是先导入了，xdm\n分为两类，一种是监听ref定义的响应式数据，一种是使用reactive定义的响应式数据\n先说一下他的配置项  （根据自己的需求在 后面定义就可以）\n总结：immediate: true,表示组件渲染时立即调用deep:true，表示深度监听对象里面的子属性（被侦听的内容需要是函数的写法）\n\n1，监听ref定义的\n// 1、侦听器-基本类型const count = ref(10)// 侦听普通值基本使用watch(count, (newValue, oldValue) =&gt; &#123;  console.log(newValue, oldValue)&#125;)\n\n2，监听reactive定义的\nconst obj = reactive(&#123;  msg: &#x27;tom&#x27;&#125;)// 侦听对象// watch(obj, (newValue, oldValue) =&gt; &#123;watch(obj, () =&gt; &#123;  // console.log(newValue === oldValue)  console.log(obj.msg)&#125;)const handleClick = () =&gt; &#123;  obj.msg = &#x27;jerry&#x27;&#125;\n\n3，监听reactive定义的响应式数据的某一个属性  （这种方法就是根据需求而来的）\n// 4、侦听对象中的某个属性// 如果侦听对象中当个属性，需要使用函数方式setup()&#123; const stuInfo = reactive(&#123;      uname: &#x27;lisi&#x27;,      age: 12,      friend: &#123;        uname: &#x27;zhangsan&#x27;      &#125;    &#125;)watch(() =&gt; obj.age, (v1, v2) =&gt; &#123;  console.log(v1, v2)&#125;)&#125;\n\n4，监听多个响应式数据数据\n// 3、侦听器-侦听多个数据const n1 = ref(1)const n2 = ref(2)watch([n1, n2], (v1, v2) =&gt; &#123;  // v1和v2都是数组  // v1表示被监听的所有值的最新值  // v2表示被监听的所有值的原有值  console.log(v1, v2)&#125;)\n\nreactive和ref的区别从定义数据角度对比\n​\t ref用来定义基本数据类型\t\t\n​\treactive用来定义 对象或数组，类型数据\n从原理角度对比\n​\tref通过Object.defineProperty()的get和set方法来实现响应式（数据劫持）\n​\treactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据\n从使用角度对比\n​\tref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value\n​\treactive定义的数据：操作数据与读取数据：均不需要.value\n","categories":["Vue3"]},{"title":"Vue3 笔记","url":"/2021/07/18/vue3%E7%AC%94%E8%AE%B0/","content":"1，什么是组合式的API?将相关联的代码保持在了一起，那么我们的代码将更具有可读性，因此也更具有可维护性。\nsetup组件选项setup有两个参数， props  和 context\n1,setup 函数中的第一个参数是 props。setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，(不能直接console.log(props.title)   &#x3D;&gt;&gt;undinfd) ，它会消除 prop 的响应性。 \n所以要使用toRefs\nconst &#123; title &#125; = toRefs(props)console.log(title.value)\n\n2,传递给 setup 函数的第二个参数是 context。context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：\n响应式变量 ref，reactive在 Vue 3.0 中，我们可以通过一个新的 ref 函数使任何响应式变量在任何地方起作用\nvue2选项式API\nvue3组合式API\ntoref()  映射一个方法\ntorefs() 映射全部方法\ntoRefs?\n计算属性和监听属性？计算属性 computed，  监听属性 wathch  watchEffect\t\n\n\n生命周期函数：主要有三个：\n组件诞生：onMounted（）\n组件更改：onUpdated（）\n组件卸载：onUnmounted（）\n全局属性：在main.js中设置例如设置axios   &#x3D;&gt;&gt;   app.config.globalProperties.http &#x3D; axios \nvue3实例获取：因为vue3中不能用this，所以要使用另一个方法getCurrentInstance  具体用法，下方：\n\n数组赋值：不能直接给数组等于   例如要改变列表的话要使用   tolist.push(…res.data)\n组件传值：父传子：\n子传父：\n兄弟传值：\nprovide  inject 传值方法直接定义，然后取就可以  很简单，不过使用的时候都要导入  \n\n\nvue3中代码复用 Mixin在入口文件main.js中定义即可\n**\n过滤器全局过滤器\n\n\n\n","categories":["Vue3"]},{"title":"私人","url":"/2022/05/28/%E4%B8%AA%E4%BA%BA/","content":"Welcome to my blog, enter password to read.         Decrypt      U2FsdGVkX19MJGFJyL/Fd7DunnbS0nTK7Hm2e1m8h0fkOZZkTIdVDfANd50hwcjcOI7DhNSeUDWA2r61Mr2BVZsNNaFcqJ6trXC5GBJZGLN93iWjl+4NI9EcCyyrD503fSAnRhVkYxvJHUZtX5J2g1Vx691CKT3Z+fnTG/v1mTNhWK/ERfL1noqqprt/kPaXaIzlXoiQj9IhANSR7563/O6cJlv+X7aK/dwz+Nv7RJ+HJiUJsmRsU6jLNAiebs1SBdhkr3f3ohFDkClPM1T8rZxd09y5TTXKEUrYwwWKK0jf3+R7FWVjQDB1KwRhYepe+CNJJOonbHx+NgriLYyV+qrLRk5KloPll6nn6LWHqzwlTUkzWG6jb+tyT03C6zISHi5E0JjMuY9SUMrWz5RgfOWImhng/nlGVKD1jC8qoojwe0Hu1u2LzTop6BBGtoR7SclU3VD7kD8Zu7m1GChYlEUpDTwFber/rkaWOG2MPiuhKwjL1bEzCViIjO4VD803fnYMLRDjEnthRKa+Bp3nUeN3izHaLeAzvPaSpT9vVJoJBoPjVDMlLH8rrwZPDdg6YIQvpjtYz6tD5RKlNwpQq2SajUYhRiF2zjN3SldY+2XtI/V7tu0u2NpaA1ebKwZA4ZzZ7os1tAU4sf/d3ucMp7eK64YhdhBBoBoBgZS85xdEeuae6ScHKLwK7ytRKZKnGKm3rUYqWQ95lv/iadl30SvoU1csa34xrfbKPk6ri5xdUROs97CYg4OzNLR9I1HsBOEwe3BgPqKBCV9AcohEoE5ZmIMPklNdIbu4w0Zl1nubVeDjdRA0wQ80CyEoy53QgI7djExb939NfddbTrAD4NmRfubHnhUlGuXOukrVXg2DLJ9f/h5k1MKlEn1yKe/D1ZteENGTrz6AZEKHhGXsRq6YrDt60gwshZm1kCc9ASc= "},{"title":"函数组件和类组件的区别","url":"/2021/01/21/%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8C%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"是什么？类组件是通过类的编写形式去编写组件，该类必须继承与react.Component，如果要访问父组件传递过来的参数，可以通过this.props的方式去访问，在组件中必须实现render方法， 在return中返回react对象，\n函数组件就是通过函数编写形式去编写组件，是react中定义组件最简单的方式，函数的第一个参数为props用于接收父组件传递的参数，\n区别:1:接收父组件传递参数的方式不一样，函数组件是通过第一个参数，类组件是通过this.props()\n2:状态管理，函数组件是无状态组件，没有state，但是可以通过hooks来添加react特性，类组件中有state\n3:生命周期，在函数组件中，不存在生命周期，因为生命周期钩子都是继承于react.Component,所以，要用到生命周期之只能使用类组件，\n4:调用方式，函数组件就直接调用函数，类组件需要将组件实例化，然后调用实例对象的render方法，\n总结：函数组件语法更短，更简单，这样更容易开发，理解，如果是简单的需求就使用函数组件，\n类组件有react的特性以及生命周期方法，更适合与开发 逻辑比较复杂的项目\n","categories":["React"]},{"title":"webpack","url":"/2021/03/16/webpack/","content":"介绍一下webpack的构建流程Webpack首先会把配置参数和命令行的参数及默认参数合并，并初始化执行环境所需要的参数；初始化完成后会调用Compiler（肯拍le）的run来真正启动webpack编译构建过程，webpack的构建流程包括compile、make、build、seal、emit阶段初始化参数，开始编译，确定入口，编译模块， 完成编译之后 进行输出\n打包流程\n\n初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。\n开始编译：从上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。\n确定入口：根据配置中的 entry 找出所有的入口文件。\n编译模块：从入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。\n完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。\n输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。\n输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\n\n介绍Loaderloader就是模块转换化，或叫加载器。不同的文件，需要不同的loader来处理。\n编写原则：\n​\t单一原则：每个Loader只做一件事；\n​\t链式调用：Webpack会按顺序链式调用每个Loader\n​\t同一原则：遵循Webpack制定的设计规则和结构，输入与输出均为字符串，\n​\t\t\t\t\t\t每个Loader完全独立，即插即用\n配置方式：\n 我一般用的方式是在webpack.config.js文件中指定loader，这个也是比较常用的，还有另外的方式\n比如； 内联方式，在每个import语句中显式指定loader\n常用Loader：\n\nfile-loader: 加载文件资源，如 字体 &#x2F; 图片 等，具有移动&#x2F;复制&#x2F;命名等功能；\nurl-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；\nbabel-loader: 加载 js &#x2F; jsx 文件， 将 ES6 &#x2F; ES7 代码转换成 ES5，抹平兼容性问题；\nts-loader: 加载 ts &#x2F; tsx 文件，编译 TypeScript；\nstyle-loader: 将 css 代码以&lt;style&gt;标签的形式插入到 html 中；\ncss-loader: 分析@import和url()，引用 css 文件与对应的资源；\npostcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等；\nless-loader / sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率；\n\n介绍PluginPlugin其实可以看作是插件系统  ，在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。\n常用 Plugin:\n\nUglifyJsPlugin: 压缩、混淆代码；\nCommonsChunkPlugin: 代码分割；\nProvidePlugin: 自动加载模块；\nhtml-webpack-plugin: 加载 html 文件，并引入 css &#x2F; js 文件；\nextract-text-webpack-plugin &#x2F; mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；\noptimize-css-assets-webpack-plugin: CSS 代码去重；\nwebpack-bundle-analyzer: 代码分析；\ncompression-webpack-plugin: 使用 gzip 压缩 js 和 css；\nhappypack: 使用多进程，加速代码构建；\nEnvironmentPlugin: 定义环境变量；\n\nloader和plugin有什么区别？webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它laoder可以识别的内容。\n\nloader就是模块转换化，或叫加载器。不同的文件，需要不同的loader来处理。\nplugin是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。\n\nwebpack 热更新实现原理无需完全刷新整个页面的同时，更新模块              节省开发时间、提升开发体验。\n首先是建立起浏览器端和服务器端之间的通信，浏览器会接收服务器端推送的消息，如果需要热更新，浏览器发起http请求去服务器端获取打包好的资源解析并局部刷新页面。\t\nwebpack 层面如何做性能优化无用代码消除     即 删除不可能执行的代码；\n消除那些被 引用了但未被使用 的模块代码。\n代码分割技术（code-spliting），将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；\n优化webpack打包速度\n优化打包体积\n介绍一下 Tree ShakingTree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，\n简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码\t\nTree shaking无非就是做了两件事：\n\n编译阶段利用ES6 Module判断哪些模块已经加载\n判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n通过Tree shaking，\n\n减少程序体积（更小）\n减少程序执行时间（更快）\n便于将来对程序架构进行优化（更友好）\n\n介绍一下 webpack scope hosting作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；\nWebpack Proxy工作原理？为什么能解决跨域webpack proxy，即webpack提供的代理服务\n基本行为就是接收客户端发送的请求后转发给其他服务器\n其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）\n想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server\n我们通常是在webpack.config.js中通过devServer属性提供，它下面配置proxy 一般就是配置一下它的目标地址target\n工作原理proxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器\n比如，在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中\nWebpack Proxy怎样解决的跨域问题？所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题\n通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者\n当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据\n注意：「服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制」\n介绍一下 babel原理Babel 是编译工具，把高版本语法编译成低版本语法，或者将文件按照自定义规则转换成js语法。\nbabel 的编译过程分为三个阶段：先分析(parsing)、再转化（transforming）、最后生成代码（generating）。\n介绍一下RollupRollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。\nRollup优势：\n\n输出结果更加扁平，执行效率更高；\n自动移除未引用代码；\n打包结果依然完全可读。\n\n缺点\n\n加载非 ESM 的第三方模块比较复杂；\n因为模块最终都被打包到全局中，所以无法实现 HMR；\n浏览器环境中，代码拆分功能必须使用 Require.js 这样的 AMD 库\n\n总结一下：Webpack 大而全，Rollup 小而美。\n在对它们的选择上，我的基本原则是：应用开发使用 Webpack，类库或者框架开发使用 Rollup。\n","categories":["Webpack"]},{"title":"centos中安装nginx","url":"/2022/05/27/%E5%AE%89%E8%A3%85nginx/","content":"y要先安装所需插件\nyum的话应该是需要切换到root才可以使用\n1：安装gcc        这个一般都是自带都有   查看一些  gcc  -v   如果没有  可以yum  -y  install gcc\n2: pcre, prce-devel安装     yum install -y pcre pcre-devel      \n3:安装 zlib               yum  install  -y   zlib  zlib-devel\n4：安装openssl  yum install -y openssl openssl-devel\n5: 下载Nginx         wget  http://nginx.ort/download/nginx-1.16.1.tar.gz\n这里会下载一个压缩文件        \n6:解压nginx压缩文件       tar -zxvf nginx-1.16.1.tar.gz        这里应该是要注意下目录的\n7:写如配置文件，为编译安装做准备  (先试一下make，可不可以编译，不可以的话就写配置文件)\n./configure \\--prefix=/usr/local/nginx \\--conf-path=/usr/local/nginx/conf/nginx.conf \\--pid-path=/usr/local/nginx/conf/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi\n\n8:编译安装\nmake\nmake install\n9:启动     &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;ngiinx\n如果不能正确启动  ，那就是报下面的错误，\nnginx: [emerg] mkdir() “&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client” failed (2: No such file or directory)\n意思是少一个文件夹，以下方法就可以解决\n[root@localhost sbin]# sudo mkdir -p &#x2F;var&#x2F;temp&#x2F;nginx   \n如果运行成功 但不显示的话，可以关闭防火强，systemctl stop firewalld    开启就是start\n这样的话就成功在centos中安装nginx了，并成功运行，  下一步是把vue项目部署到centos上\n"},{"title":"区分真实dom和虚拟dom","url":"/2021/01/19/%E5%8C%BA%E5%88%86%E8%99%9A%E6%8B%9Fdom%E5%92%8C%E7%9C%9F%E5%AE%9Edom/","content":"Real DOM（真实dom）\n\nReal DOM，真实DOM， 意思为文档对象模型，在页面渲染出的每一个结点都是一个真实DOM结构\n我们在控制台看到的dom结构就是真实dom\n\n更新缓慢\n\n可以直接更新 HTML\n\n如果元素更新，则创建新DOM\n\nDOM操作代价很高\n\n消耗的内存较多\n\n\nVirtual DOM（虚拟dom）\n​\tVirtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述。创建虚拟DOM目的就是为了\t\t更好将虚拟的节点渲染到页面视图中，虚拟DOM对象的节点与真实DOM的属性一一照应​\t更新更快​\t无法直接更新 HTML​\t如果元素更新，则更新 JSX​\tDOM 操作非常简单​\t很少的内存消耗​\t\n","categories":["React"]},{"title":"搭建博客流程/问题","url":"/2017/05/17/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98/","content":"Welcome to 第一篇文章，我在这里记录我创建博客时的问题流程dir\t查询文件目录hexo serve 启动hexo n “我的第一篇文章”hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写\n添加标签： 在需要添加标签的文章里在data后加\ncategories：  \n​\t- Python\n部署到github  需要下载hexo-deployer-git需要到_config.yml下的Deployment去配置type&#x3D;”git”和git地址然后就可以进行部署  hexo d \n问题–都为两个—-\n1， 配置你的github用户名和和邮箱，\n​\t\tgit config –global user.email “&#x64;&#97;&#x6d;&#105;&#x6e;&#103;&#49;&#55;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;“ \n​\t\tgit config –global user.name “daming-Z”\n2，取消git本身的https代理，使用自己本机的代理，\n​\t\t取消http代理* \t  git config –global –unset http.proxy \n​\t\t取消https代理*  \tgit config –global –unset https.proxy\n3，生成github令牌流程\n​\t\thttps://blog.csdn.net/yjw123456/article/details/119696726\n4，keep主题的配置\n​\t\thttps://zhuanlan.zhihu.com/p/368244108\n参考 bilibiliup \nhttps://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click\n设置主题\nhttps://hexo.io/themes/\n"},{"title":"怎样理解React?有什么特性？","url":"/2021/01/19/%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3React/","content":"是什么?React,用来构建用户界面的JavaScript库，让前端应用程序更高效，使用虚拟dom来有效地操作真实dom，遵循从高阶组件到低阶组件的单向数据流，很多人认为 React 是 MVC 中的 V（视图）。\n特性JSX语法\n单向数据绑定\n虚拟DOM\n声明式编程\nComponent(组件化)\n优势高效灵活\n声明式的设计，简单使用\n组件式的开发，提高代码复用率\n单向相应的数据流会比双向绑定的更安全，速度更快\nReact和vue的区别？1.监听数据变化的实现原理不同​\tvue是通过getter&#x2F;setter以及一些函数的劫持，能精确知道数据变化，\t\n​\tReact是通过比较引用的方式（diff）进行的\n2.数据流不同​\tvue是使用的双向数据流  （双向绑定）\n​    React提倡的是单向数据流，\n​\t不过由于我们一般都会用Vuex以及Redux等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。\n3.Vuex和Redux的区别最大的区别是两点：\n​\t\t\t\tRedux使用的是不可变数据，而Vuex的数据是可变的，\n​\t\t\t\tRedux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter&#x2F;setter来比较的\n​\t\t\t\t也是因为React和Vue的设计理念不同。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。\n4.组件传值的方式不同\nvue更倾向于事件，而React中我们都是使用回调函数\n5.框架本质不同Vue本质是MVVM框架，由MVC发展而来；\nReact是前端组件化框架，由后端组件化发展而来。\n","categories":["React"]},{"title":"必背面试题","url":"/2018/09/12/%E5%BF%85%E8%83%8C%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"说说你对盒子模型的理解当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）\n一个盒子由四个部分组成：content、padding、border、margin\ncontent，即实际内容，显示文本和图像\nboreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成\npadding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响\nmargin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域\n在CSS中，盒子模型可以分成：\n\nW3C 标准盒子模型\nIE 怪异盒子模型\n\n默认情况下，盒子模型为W3C 标准盒子模型\n标准盒子模型标准盒子模型，是浏览器默认的盒子模型\n也就是，width/height 只是内容高度，不包含 padding 和 border值\nIE 怪异盒子模型也就是，width/height 包含了 padding和 border值\ncss选择器有哪些？优先级？\nid选择器（#box），选择id为box的元素\n类选择器（.one），选择类名为one的所有元素\n标签选择器（div），选择标签为div的所有元素\n后代选择器（#box div），选择id为box元素内部所有的div元素\n子选择器（.one&gt;one_1），选择父元素为.one的所有.one_1的元素\n相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素\n群组选择器（div,p），选择div、p的所有元素\n\n优先级!important &gt;内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器\n继承属性在css中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性.\nfont-size, font-family, color\n元素水平垂直居中的方法有哪些？如果元素不定宽高呢？实现元素水平垂直居中的方式：\n\n利用定位+margin:auto\n\n利用定位+margin:负值\n\n利用定位+transform\n\ntable布局\n\nflex布局\n\ngrid布局\n\n怎么理解回流跟重绘？什么场景下会触发？\n\n回流：布局引擎会根据各种样式计算每个盒子在s页面上的大小与位置\n重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制\n· 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘\n· 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏&#x2F;状态状态）发生改变时，产生重绘回流\n· 回流必将引起重绘，而重绘不一定会引起回流\n什么是响应式设计？响应式设计的基本原理是什么？如何做？优点：面对不同分辨率设备灵活性强\n能够快捷解决多设备显示适应问题\n缺点：仅适用布局、信息、框架并不复杂的部门类型网站\n兼容各种设备工作量大，效率低下\n代码累赘，会出现隐藏无用的元素，加载时间加长\n其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果\n一定程度上改变了网站原有的布局结构，会出现用户混淆的情况\n如果要做优化，CSS提高性能的方法有哪些？每一个网页都离不开css，但是很多人又认为，css主要是用来完成页面布局的，像一些细节或者优化，\n减少css嵌套，最好不要套三层以上。\n不要在ID选择器前面进行嵌套，ID本来就是唯一的而且人家权值那么大，嵌套完全是浪费性能。\n建立公共样式类，把相同样式提取出来作为公共类使用，比如我们常用的清除浮动等。\t\n不用css表达式，表达式只是让你的代码显得更加炫酷，但是他对性能的浪费可能是超乎你的想象的。\n对前端工程师这个职位是怎么样理解的？它的前景会怎么样?我认为前端工程师是最贴近用户的，是以用户需求为中心，通过不同的改进和亲身体验来完成用户的需求，让用户的交互效果更加舒服，\n以前前端的可能就写一些页面，很简单的工作，现在可以通过vue，react等框架来让交互效果更加理想，也把后端的一些任务放到前端处理，所以，前端不仅仅要面对用户，还要面对，后端，产品经理，等所以前端并不局限于前端技术还要会一点后端，会一点产品， 每个前端人员往往都会往全栈的方向去发展，当然这也是我的一个目标，这就我对前端开发人员的理解+\n说说JavaScript中的数据类型？存储上的差别？js的数据类型分为两类，一个是基本数据类型，一个是引用数据类型\n基本数据类型有undefined、null、boolean、number、string、symbol\n引用数据类型有\tobject\n在js的执行过程中，主要有三种数据类型内存空间，分别是代码空间，栈空间，堆空间，其中的代码空间主要是存储可执行代码的，原始类型的数据值都是直接保存在栈中的，引用数据类型的值是存放在堆空间中的，   原始数据类型存储的是变量的值，而引用数据类型存储的是其在堆空间中的地址。\ntypeof 与 instanceof 区别typeof 对于原始数据类型来说，除了null都可以正确的显示类型\n对于引用数据类型来说，除了函数，都会显示object  \n这样看来typeof它并不能正确的显示数据类型，\ninstanceof 可以正确显示数据类型， 因为它是通过对象的原型链来进行判断的，\n说说你对闭包的理解？闭包使用场景闭包就是可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，创建一个闭包最简单的方法就是在一个函数内创建一个函数，它有三个特性是  函数内可以再嵌套函数，内部函数可以访问外部的方法和变量，方法和变量不会被垃圾回收机制回收，\n它的优点就是可以实现封装和缓存，缺点就是可能会造成内存泄漏的问题\nbind、call、apply 区别？如何实现一个bind?\ncall 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。\n\n除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组\n\ncall和apply他们的返回结果是直接执行的，bind的返回结果是待执行函数\n\nbind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化       柯里化技术，主要体现在函数里面返回函数。\n实现bind的步骤，我们可以分解成为三部分：\n\n修改this指向\n动态传递参数\n\n兼容new关键字\n\n\n\n\n说说你对事件循环的理解首先，JavaScript是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环\n在JavaScript中，所有的任务都可以分为\n\n同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行\n\n异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等\n同步任务进入主线程，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环\n异步任务还可以细分为微任务与宏任务\n\n\n宏任务与微任务微任务当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。\n常见的微任务有：\n\nPromise.then\nMutaionObserver\nObject.observe（已废弃；Proxy 对象替代）\nprocess.nextTick（Node.js）\n\n宏任务当前调用栈中执行的代码成为宏任务。\n常见的宏任务有：\n\nscript (可以理解为外层同步代码)\nsetTimeout&#x2F;setInterval\nUI rendering&#x2F;UI事件\npostMessage、MessageChannel\nsetImmediate、I&#x2F;O（Node.js）\n\nDOM常见的操作有哪些1.查找节点. 2.新建节点. 3.添加新节点. 4.删除节点. 5.设置样式. \n创建节点：document.createElement(“元素名”)\n删除节点：parentNode.removeChild(existingChild)删除已有的子节点，返回值为删除节点\n修改节点：parentNode.replaceChild(newChild,existingChild)用新节点替换父节点中已有的子节点\n查找节点：document.getElementByid(“id属性值”) 返回拥有指定id的第一个对象的引用\n设置样式,ele.style.styleName &#x3D; styleValue\n说说你对BOM的理解，常见的BOM对象你了解哪些？BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象\n其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率\n浏览器的全部内容可以看成DOM，整个浏览器可以看成BOM。\n常见的BOM对象有\n1、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；\n2、document对象，文档对象；\n3、location对象，浏览器当前URL信息；\n4、navigator对象，浏览器本身信息；\n5、screen对象，客户端屏幕信息；\n6、history对象，浏览器访问历史信息；\nJavascript本地存储的方式有哪些？区别及应用场景？javaScript本地缓存的方法我们主要讲述以下四种：\n\ncookie\nsessionStorage\nlocalStorage\nindexedDB\n\ncookieCookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题\n作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成\n但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。\nlocalStorageHTML5新方法\n\n生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的\n存储的信息在同一域中是共享的\n当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。\n大小：5M（跟浏览器厂商有关系）\nlocalStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n受同源策略的限制\n\n下面再看看关于localStorage的使用\nlocalStorage.setItem(&#x27;username&#x27;,&#x27;cfangxu&#x27;);\n\nlocalStorage.getItem(&#x27;username&#x27;)\t\n\nlocalStorage.removeItem(&#x27;username&#x27;)\n\nlocalStorage.clear()\n\nlocalStorage 也不是完美的，它有两个缺点：\n\n无法像Cookie一样设置过期时间\n只能存入字符串，无法直接存对象\n\nsessionStoragesessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据\n**indexedDB **用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用索引来实现对该数据的高性能搜索\n区别关于cookie、sessionStorage、localStorage三者的区别主要如下：\n\n存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\n有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\n应用场景在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：\n\n标记用户与跟踪用户行为的情况，推荐使用cookie\n适合长期保存在本地的数据（令牌），推荐使用localStorage\n敏感账号一次性登录，推荐使用sessionStorage\n存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB\n\n什么是防抖和节流？有什么区别？如何实现？\n节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效\n防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时\n\n一个经典的比喻:\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应\n假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制\n电梯第一个人进来后，15秒后准时运送一次，这是节流\n电梯第一个人进来后，等待15秒。如果过\t程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖\n区别相同点：\n\n都可以通过使用 setTimeout 实现\n目的都是，降低回调执行频率。节省计算资源\n\n不同点：\n\n函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能\n函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次\n\n应用场景防抖在连续的事件，只需触发一次回调的场景有：\n\n搜索框搜索输入。只需用户最后一次输入完，再发送请求\n手机号、邮箱验证输入检测\n窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。\n\n节流在间隔一段时间执行一次回调的场景有：\n\n滚动加载，加载更多或滚到底部监听\n搜索框，搜索联想功能\n\n如何通过JS判断一个数组instanceof方法\t\t\n\ninstanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性\n\nconstructor方法\n\nconstructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数\n\nvar arr = [];arr.constructor == Array; //true\n\n\nES5新增方法isArray()\n\nvar a = new Array(123);var b = new Date();console.log(Array.isArray(a)); //trueconsole.log(Array.isArray(b)); //false\n\n说说你对作用域链的理解\n作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的\n简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\nJavaScript原型，原型链 ? 有什么特点？\n每个对象都会在其内部初始化一个属性，就是__proto__，当我们访问一个对象的属性时\n如果这个对象内部不存在这个属性，那么他就会去__proto__里找这个属性，这个__proto__又会有自己的__proto__，于是就这样一直找下去，也就是我们平时所说的原型链的概念。\n原型特点：\nJavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变\n\n\n\n请解释什么是事件代理\n事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能\n可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒\n可以实现当新增子对象时无需再次对其绑定\n\n谈谈This对象的理解\nthis总是指向函数的直接调用者（而非间接调用者）\n如果有new关键字，this指向new出来的那个对象\n在事件中，this指向触发这个事件的对象\n\nnew操作符具体干了什么\n创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型\n属性和方法被加入到 this 引用的对象中\n新创建的对象由 this 所引用，并且最后隐式的返回 this\n\nnull，undefined 的区别\nundefined 表示不存在这个值。\t\nnull 表示一个对象被定义了，值为“空值”\n\njavascript 代码中的”use strict”;是什么意思\nuse strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为\n\n同步和异步的区别\n同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作\n异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容\n\n谈一谈箭头函数与普通函数的区别1：定义语法的格式不一样 普通函数用function  箭头函数用箭头声明\n2：普通函数可以用作构造函数，可以调用new，有原型， 箭头函数都不可以 \n3：普通函数有arguments（参数a g有 们 是） ， 箭头函数没有，但是可以调用外围的arguments对象  arguments是给函数传入参数的时候可以像数组一样调用数组的元素或属性\t\n4：普通函数的this是动态的， 箭头函数中的this一般指向全局对象window 如果被普通函数包含，就指向上一层\n5：普通函数可以通过call ，apply，bind方法改变this的指向， 箭头函数不能\nJS中的数组的方法pop     push     shift     unshift0\njoin \narray    array.fill       array.from\nsplice    indexOf   includes\nsort  reverse \nfind   findIndex\ntoString\nJS 数组和对象的遍历方式，以及几种方式的比较\nfor in循环\nforEach   forEach 无法遍历对象  无法使用break,continue来跳出循环，可以使用return，没有返回值\nmap  不会对一个空数组进行检测   map方法有返回值，可以return出来，仅用于对数组的循环 \nfilter\n\n如何解决跨域问题跨域问题如何产生：\n浏览器有一个安全机制，叫同源策略，就是指协议域名端口都一致 当一个请求url的协议，域名，端口任意一个与当前页面url不一致，为跨域\nnginx代理跨域\nnode.js中间件代理跨域\n后端添加安全域名\nXML和JSON的区别\n数据体积方面\nJSON相对于XML来讲，数据的体积小，传递的速度更快些。\n\n\n数据交互方面\nJSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互\n\n\n数据描述方面\nJSON对数据的描述性比XML较差\n\n\n传输速度方面\nJSON的速度要远远快于XML\n\n\n\n谈谈你对webpack的看法\nWebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用\n\nwebpack的打包原理*webpack中每个模块有一个唯一的id，是从0开始递增的。整个打包后的bundle.js是一个匿名函数自执行。参数则为一个数组。数组的每一项都为个function。function的内容则为每个模块的内容，并按照require的顺序排列我们看到_webpack_require是模块加载函数，接收模块id（对，webpack中每个模块都会有一个独一无二的id，其实也就是在IIFE传参数组中的索引值（0，1，2…）a依赖b，所以在a中调用webpack加载模块的函数\n如何优化webpack打包速度*在package.json中的dev配置的时候，配置加上--hot即可\n使用fast-sass-loader代替sass-loader\n提取公共代码\n说说webpack中常见的Loader？解决了什么问题？*loader 用于对模块的”源代码”进行转换，在 import 或”加载”模块时预处理文件\n关于配置loader的方式有三种：\n\n配置方式（推荐）：在 webpack.config.js文件中指定 loader\n内联方式：在每个 import 语句中显式指定 loader\nCLI 方式：在 shell 命令中指定它们\n\n说说webpack中常见的Plugin？解决了什么问题？ *plugin赋予其各种灵活的功能，它们会运行在 webpack 的不同阶段（钩子 &#x2F; 生命周期），目的在于解决loader 无法实现的其他事\n配置方式：一般情况，通过配置文件导出对象中plugins属性传入new实例对象\nPromise对象的then方法用来接收处理成功时响应的数据，catch方法用来接收处理失败时相应的数据。\n说说你对promise的了解可以把Promise看做一个容器，里边存放了异步操作，主要解决了回调地狱的问题，\npromise构造函数接收一个函数作为参数，该函数的两个参数为resolve,reject。异步任务执行成功时调用resolve函数返回结果，执行失败调用reject\nPromise对象的then方法用来接收处理成功时响应的数据，catch方法用来接收处理失败时相应的数据。\nasync函数是什么，有什么作用。async/await从字面意思上很好理解，async是异步的意思，await有等待的意思，而两者的用法上也是如此。\nasync用于申明一个function是异步的，而await 用于等待一个异步方法执行完成。\nasync 表示这是一个 async 函数，而 await 只能在这个函数里面使用。\n*async、await 优缺点\n\nasync 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性\n\nasync&#x2F;await和promise的区别Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了，但是如果业务场景是这样呢？我们先调起promise1，然后根据返回值，调用promise2，之后再根据这两个Promises得值，调取promise3。  这样的话代码非常不直观，会有很多嵌套，显得臃肿\nconst req = () =&gt; &#123;    return promise1()        .then(value1 =&gt; &#123;            // do something            return promise2(value1)                .then(value2 =&gt; &#123;                    // do something                              return promise3(value1, value2)                &#125;)        &#125;)&#125;\n\n在相同的业务场景下，async&#x2F;await的好处就来了，\nconst req = async () =&gt; &#123;    const value1 = await promise1()    const value2 = await promise2(value1)    return promise3(value1, value2)&#125;\n\n有使用过vue吗？说说你对vue的理解是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架\n它提供了 MVVM数据绑定\nMVVM表示的是 Model-View-ViewModelModel：模型层，负责处理业务逻辑以及和服务器端进行交互View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面\t\t\tViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁Vue核心特性，数据驱动（MVVM)，组件化，在Vue中每一个.vue文件都可以视为一个组件，降低整个系统的耦合度，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，\nvue提供了钩子函数，在不同的生命周期来执行不同的钩子函数，然后可以在钩子函数内写业务逻辑来实现我们的需求，\nvue小比较轻，适合做一些小而快的项目\n你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢翻译过来就是单页应用，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验\n我们熟知的JS框架如react,vue,angular,ember都属于SPA\nSPA和MPA的区别MPA翻译过来就是多页应用，在MPA中每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件\n单页应用与多页应用的区别\n\n\n\n单页面应用（SPA）\n多页面应用（MPA）\n\n\n\n组成\n一个主页面和多个页面片段\n多个主页面\n\n\n刷新方式\n局部刷新\n整页刷新\n\n\nurl模式\n哈希模式\n历史模式\n\n\nSEO搜索引擎优化\n难实现，可使用SSR方式改善\n容易实现\n\n\n数据传递\n容易\n通过url、cookie、localStorage等传递\n\n\n页面切换\n速度快，用户体验良好\n切换加载资源，速度慢，用户体验差\n\n\n维护成本\n相对容易\n相对复杂\n\n\n单页应用优缺点优点：\n\n用户体验好、快，内容的改变不需要重新加载整个页面\n良好的前后端分离，分工更明确\n\n缺点：\n\n不利于搜索引擎的抓取\n首次渲染速度相对较慢\n\n实现一个SPA\n原理\n\n监听地址栏中hash变化驱动界面变化\n用pushsate记录浏览器的历史，驱动界面发送变化\n\nSPA首屏加载速度慢的怎么解决？首屏时间（First Contentful Paint），指的是浏览器从用户输入url地址，到首屏内容渲染完成的时间，\n加载慢的原因\n网络延时问题\n资源文件体积是否过大\n资源是否重复发送请求去加载了\n加载脚本的时候，渲染内容堵塞了\n\n常见的几种SPA首屏优化方式\n减小入口文件体积\t\t常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加\n静态资源本地缓存         前端合理利用localStorage\nUI框架按需加载             在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库\n图片资源的压缩             对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻          http请求压力。\n组件重复打包\n\nVUE路由的原理通过改变 URL，在不重新请求页面的情况下，更新页面视图。\n更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有2种方式：\n1.Hash — 利用 URL 中的hash(“#”);\n2.利用 History interface 在HTML5中新增的方法。\nVue 中，它是通过 mode 这一参数控制路由的实现模式：\nVue中组件和插件有什么区别？组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件\n插件通常用来为 Vue 添加全局功能。一般是别人写好的一些东西，可以拿来直接用\n两者的区别主要表现在以下几个方面：\n\n编写形式\n\n每一个.vue文件我们都可以看成是一个组件\n我们还可以通过template属性来编写一个组件\nvue插件的实现应该暴露一个 install 方法，第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象\n\n\n注册形式\n\n全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项\n局部注册只需在用到的地方通过components属性注册一个组件\n插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项\n\n\n使用场景\n\n组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue \n插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身\n简单来说，插件就是指对Vue的功能的增强或补充\n\n\nVue组件之间的通信方式都有哪些组件间通信的分类可以分成以下\n\n父传子\n通过 props 传递\n子组件设置props属性，定义接收父组件传递过来的参数\n父组件在使用子组件标签中通过字面量来传递值\n\n\n子传父\n$emit 触发自定义事件\n子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\n父组件绑定监听器获取到子组件传递过来的参数\n\n\n兄弟组件之间的通信\n兄弟组件传值是通过EventBus\n创建一个EventBus.js文件，里边主要是到处Vue实例\n发送数据组件调用bus.$emit(‘事件名’,传递的数据)\n接收数据组件调用bus.$on(“事件名”,回调函数)我们就可以通过回调函数的形参\n\n\n祖孙与后代组件之间的通信\n非关系组件间之间的通信\n\n虚拟DOM的理解Virtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述\n存储在内存中，创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象的节点与真实 DOM 的属性一一照应\n你了解vue的diff算法吗？说说看“diff算法就是进行虚拟节点对比,并返回一个patch对象,用来存储两个节点不同的地方,最后用patch记录的消息去局部更新Dom。”\n其有两个特点：\n\n比较只会在同层级进行, 不会跨层级比较\n标签名不同的话，直接删掉，\n在diff比较的过程中，循环从两边向中间比较\n\ndiff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较\ndiff整体策略为：深度优先，同层比较\n为什么需要 Virtual Dom因为要直接操作真实dom的话，每次都会进行页面的刷新，\n虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能\n\n虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘\n\nVue3.0的设计目标是什么？做了哪些优化设计目标：更小更快更友好\n更小Vue3`移除一些不常用的 `API\n\n引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了\n更快主要体现在编译方面：\n\ndiff算法优化\n静态提升\n事件监听缓存\nSSR优化\n\n更友好vue3在兼顾vue2的options API的同时还推出了composition API，大大增加了代码的逻辑组织和代码复用能力\nVue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）\n即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API\n\nComposition API中见不到this的使用，减少了this指向不明的情况\n如果是小型组件，可以继续使用Options API，也是十分友好的\n在逻辑组织和逻辑复用方面，Composition API是优于Options API\n因为Composition API几乎是函数，会有更好的类型推断。\n\n说一下Vue数据响应式的原理数据劫持结合发布订阅模式，\n首次获取data中的状态，使用es5的object.defineProperty对每一个状态进行getter,setter,\n当获取数据时，new一个Dep()对象，该对象中有sub数组，sub数组中是通过watchar收集的依赖，\n模板调用状态的地方会生成一个watcher，当修改数据时走setter，通过dep的实例对象调用notify方法，通知观察者watcher，执行update生成新的虚拟DOM树，Vue框架会遍历并对比新虚拟DOM树和旧虚拟DOM树中每个节点的差别，并记录下来，\n说说对 React 的理解？有哪些特性？React 是一个构建用户界面的javascript库\n\n它的核心设计思路有三点，分别是声明式、组件化与 通用性。\n声明式的优势在于直观与组合。\n组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合。\n\n特性有\n​\t使用类似 HTML 的JSX语法来描述视图\t它是JavaScript的语法扩展。，JSX 看起来像HTML，减少学习成本，代码更易读， JSX 并不是 \tReact 所必须的，但它非常适合 React\t\n​\t通过setState修改数据\treact状态可以改变，但不是响应式的，动态改变并没有与视图响应，想要改变并响应视图则需要 setState 修改并更新视图。\n​\t通过虚拟DOM修改真实DOM  提高性能，避免重复页面刷新\n说说 Real DOM 和 Virtual DOM 的区别？优缺点？真实DOM就是我们在浏览器开发者工具中看到的DOM结构\n虚拟DOM简单来说就是 JS 对象，此对象中的字段包含了对真实DOM的描述:\n解决了频繁操作真实 DOM 的低效率工作-不直接操作 DOM，也在一定程度上提升了性能\n更改真实dom要全部修改，会导致回流和重绘， 虚拟dom会进行局部刷新，修改某一个地方\n如果直接操作真实dom浏览器会重新加载，\n说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？生命周期是一个事务从诞生到销毁的过程，\n在react中生命周期分为三个部分 挂载，更新，卸载\n挂载阶段：componentWillMount ，componentDidMount\n更新阶段：componentWillUpdate和componentDidUpdate\n卸载阶段：componentWillUnmount\n说说 React中的setState执行机制当需要修改state的状态需要通过调用setState来改变，从而达到更新组件内部数据的作用\n\n在组件生命周期或React合成事件中，setState是异步\n在异步环境中是同步的，setTimeout或者原生dom事件中，setState是同步\n\n说说对React中类组件和函数组件的理解？有什么区别？类组件是通过类的编写形式去编写组件，该类必须继承与react.Component，如果要访问父组件传递过来的参数，可以通过this.props的方式去访问，在组件中必须实现render方法， 在return中返回react对象，\n函数组件就是通过函数编写形式去编写组件，是react中定义组件最简单的方式，函数的第一个参数为props用于接收父组件传递的参数，\n区别:\n1:接收父组件传递参数的方式不一样，函数组件是通过第一个参数，类组件是通过this.props()\n2:状态管理，函数组件是无状态组件，没有state，但是可以通过hooks来添加react特性，类组件中有state\n3:生命周期，在函数组件中，不存在生命周期，因为生命周期钩子都是继承于react.Component,所以，要用到生命周期之只能使用类组件，\n4:调用方式，函数组件就直接调用函数，类组件需要将组件实例化，然后调用实例对象的render方法，\n总结：函数组件语法更短，更简单，这样更容易开发，理解，如果是简单的需求就使用函数组件，\n类组件有react的特性以及生命周期方法，更适合与开发 逻辑比较复杂的项目\n说说对React Hooks的理解？解决了什么问题？Hook 。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\nHook可以让函数组件变成有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理\n最常见的hooks有如下：\n\nuseState        声明变量\nuseEffect       写一些事件\n\n在组件通信过程中可以使用useContext，refs学习中我们也用到了useRef获取DOM结构……\n说说你对Redux的理解？其工作原理？React是用于构建用户界面的，帮助我们解决渲染DOM的过程\n而在整个应用中会存在很多个组件，每个组件的state是由自身进行管理，包括组件定义自身的state、组件之间的通信通过props传递、使用Context实现数据共享，如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后续维护阶段，我们将花费大量精力去查询状态的变化过程\n这种情况下，我们就可以使用redux对所有的状态进行集中管理，相当于一个仓库，\n工作原理：\nredux要求我们把数据都放在 store公共存储空间\n一个组件改变了 store 里的数据内容，其他组件就能感知到 store的变化，再来取数据，从而间接的实现了这些数据传递的功能\n说说 React 性能优化的手段有哪些React凭借virtual DOM和diff算法拥有高效的性能，\n除此之外， 常见性能优化常见的手段有如下：\n\n避免使用内联函数\n\n使用 React Fragments 避免额外标记\n\n使用 Immutable\n\n懒加载组件\n\n事件绑定方式\n\n服务端渲染\nvue、react、angular 区别\nVue.js 一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters\nAngularJS 是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令\nreact React 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好\n\n\n\n说说你对 TypeScript 的理解？与 JavaScript 的区别\nTypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法\nTypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js\n在编写 TypeScript 的文件的时候就会自动编译成 js 文件\n\n说说你对 TypeScript 中泛型的理解？应用场景？泛型程序设计（generic programming）是程序设计语言的一种风格或范式\n泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型\n泛型通过&lt;&gt;的形式进行表述，可以声明：\n\n函数\n接口\n类\n\n说说你对微信小程序的理解？优缺点？2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务\n小程序是一种不需要下载安装即可使用的应用，\n优点：\n\n随搜随用，用的时候只需要搜索或扫一下就可以使用：使得小程序可以代替许多APP，\n流量大，易接受：小程序借助自身平台更加容易引入更多的流量\n安全,开发门槛低\n\n缺点：\n\n用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%\n体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序\n受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控\n\n说说你对发布订阅、观察者模式的理解？区别？观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新\n例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸\n发布订阅模式\n发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责\n区别\n观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列\n在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。\n项目做过哪些性能优化\n减少 HTTP 请求数\t\n避免重定向\n图片懒加载\n减少DOM 操作 和减少dom元素数量\n使用外部 JavaScript 和 CSS\n避免图片 src 为空\n把JavaScript放在页面底部\n写公共样式，把一些常用的样式写到公共样式\n\n描述浏览器的渲染过程，DOM树和渲染树的区别\n浏览器的渲染过程：\n解析HTML构建 DOM(DOM树)，并行请求 css/image/js\nCSS 文件下载完成，开始构建 CSSOM(CSS树)\nCSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)\n布局(Layout)：计算出每个节点在屏幕中的位置\n显示(Painting)：通过显卡把页面画到屏幕上\n\n\nDOM树 和 渲染树 的区别：\nDOM树与HTML标签一一对应，包括head和隐藏元素\n渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性\n\n\n\n你认为什么样的前端代码是好的好看和好用，\n好看就是代码可读性好，容易理解，起码注释清楚，别人接收之后上手也快，即使出现错误也好定位，还有就是规范，代码规范，命名规范，注释规范，等等，\n好用就是 高内聚低耦合，把功能相关的模块放到一起，模块与模块之间的依赖降低，复用率一定要高，\n我认为符合以上的两点的前端代码才是好的\n从浏览器地址栏输入u  rl到显示页面的步骤\n浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，&#x2F;建立相应的内部数据结构（如HTML的DOM）；\n载入解析到的资源文件，渲染页面，完成。\n\nhttp 请求报文响应报文的格式HTTP报文的组成部分有请求报文和响应报文请求报文有请求行，请求头，空行和请求体，\n请求行包括请求方法（get,post），请求头是一大堆键值对，空行是指当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体，请求体就是数据部分\n响应报文有状态行，响应头，空行和响应体，\n状态行包括状态码，以及状态描述等，\nToken cookie session 区别首先，http是一个无状态的协议，无状态就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。\ncookie和session就是解决无状态的问题，\n区别：session存储在服务器，可以理解为一个状态列表，拥有一个标识符sessionid，通常存放cookie中，服务器收到cookie后，解析出sessionid，去session列表中去查找，session依赖与cookie\ncookie是一个小型的文本文件，存放在客户端，不太安全，也可以使用https等，来提高它的安全性，\ntoken类似与一个令牌，无状态，用户信息都被加密在token中，服务器收到token后解密就可知道是哪个用户。\nJWT就是token的一种实现方式，JWT全称是JSON Web Token。基本可以看出是使用JSON格式传输token\n由三部分组成\nHeader :描述 JWT 的数据。定义了生成签名的算法以及 Token 的类型。Payload（负载）:用来存放实际需要传递的数据。Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成\nCORS跨域的原理CORS 是一种基于 HTTP Header 的机制，该机制通过允许服务器标示除了它自己以外的其它域。服务器端配合浏览器实现 CORS 机制，可以突破浏览器对跨域资源访问的限制，实现跨域资源请求。\t\nCORS 的验证机制分两种模式：简单请求和预检请求。\n简单请求模式下浏览器直接发送请求，并在请求头中携带 Origin。 服务器端接到请求后，会根据自己的跨域规则，通过响应头 Access-Control-Allow-Origin 来返回验证结果。\n需要预检的请求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，服务器基于预检请求的信息来判断是否接受接下来的实际请求。\n什么是MVVMMVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel\nModel层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，\n数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。\nMVVM表示的是 Model-View-ViewModelModel：模型层，负责处理业务逻辑以及和服务器端进行交互View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面\t\t\tViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁\n说说你对版本管理的理解？常用的版本管理工具有哪些？\n适合多人团队协作开发\n代码集中化管理\n可以离线工作\n每个计算机都是一个完整仓库\n\n常用的版本管理工具有Git和HG它可以有效地处理任何规模的项目，并提供简单直观的界面\n说说你对Git的理解？Git是分布式版本管理工具，可以把代码仓库完整地镜像下来，这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复\t\n说说Git常用的命令有哪些git init    用于创建一个新的代码库。\n通过git clone &lt;项目远程地址&gt;下载下来最新的代码，\ngit status\t显示所有需要提交的文件。\ngit add . \t提交全部文件修改到缓存区git diff\t   显示尚未添加到stage的文件的变更\ngit   log        查看提交历史\ngit merge   可以将指定分支的历史记录合并到当前分支\n说说 git 发生冲突的场景？如何解决？多个人对同一个分支进行更改  会发生冲突，\n多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称   会产生冲突\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交\njsonp的实现原理jsonp是一种跨域通信的手段，我们可以使用它来解决跨域问题\n1、首先是利用script标签的src属性来实现跨域。2、通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。3、由于使用script标签的src属性，因此只支持get方法\n对高阶组件的理解高阶组件其实就是一个函数，\t这个函数接收一个组件作为输入，返回一个新的组件作为结果，\n返回的新组件拥有了输入组件所不具有的一些功能\n好处：\n重用代码：提取出来逻辑，利用高阶组件的方式应用出去，就可以减少很多组件的重复代码，\n修改现有react组件的行为：有些现成react组件并不是开发者自己开发的，来源第三方，希望修改里边的逻辑\n受控组件和非受控组件受控组件简单来说就是受我们控制的组件，组件依赖于状态\n例如input框，我们输入之后，内容无法显示出来，我们就可以对input一个onChange事件，在函数内部实现state的更新\n非受控组件就是不受我们控制的组件，不受状态的控制，像以上那种情况，就要使用ref查询DOM查找值，\n实际上非受控组件获取数据就是相当于操作DOM\n应用场景受控组件使用场景： 一般用于需要动态设置其初始值的情况，  例如：某些form表单信息编辑时，input表单元素需要初始显示值时\n非受控组件使用场景：一般用于无任何动态初始值信息的情况，例如form表单创建，input没有初始值，需要用户输入的情况，\nhttp状态码200请求成功\n300重定向，\n400资源不存在    404没有找到页面， 405 没有权限，常见的就是我们使用网上图片，如果有防盗链的话，就会报出405\n500服务器端错误\t\n","categories":["面试题总结"]},{"title":"杂七杂八","url":"/2018/04/21/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/","content":"JS更新页面代码location.reload()\nVUE中样式只在当前页面生效 只需要在style中加上scoped\n使用原生js写一个删除提示弹出框原本的删除方法用自定义的包装一下：\t        if(confirm(‘确定要删除吗’)&#x3D;&#x3D;true){                    this.handleDelete(row)        }\nWindows设置自己的程序开机自动启动cmd打开运行，输入shell:startup，回车，也可以快速打开启动文件夹。把需要开机启动的快捷方式拉到目录下\nJavaScript setTimeout() 用法setTimeout(“alert(‘对不起, 要你久候’)”, 3000 )\n内容超过div的长度后自动出现滚动条的实现方法.div&#123;  height：80%; //须设置一个合适高度  overflow:auto; &#125;\n\ncss如何修改滚动条样式/*滚动条样式*/.innerbox::-webkit-scrollbar &#123;width: 4px;    /*height: 4px;*/&#125;.innerbox::-webkit-scrollbar-thumb &#123;border-radius: 10px;-webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);background: rgba(0,0,0,0.2);&#125;.innerbox::-webkit-scrollbar-track &#123;-webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.2);border-radius: 0;background: rgba(0,0,0,0.1);&#125;\n\n"},{"title":"节流和防抖","url":"/2020/11/05/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/","content":"","categories":["JavaScript"]},{"title":"部署vue项目到centos上","url":"/2022/05/27/%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE%E5%88%B0centos/","content":"x修改一下nginx.conf中的配置，  就是把路由改了，  root  那个目录改了， 改为dist因为待会打包vue项目是dist\n打包代码\n在vue项目目录中   使用   cmd  或git    都可以试一下，有一个管用的\n因为有的不支持scp\nscp -r dist&#x2F; &#x72;&#x6f;&#111;&#116;&#x40;&#x31;&#x33;&#x39;&#46;&#x39;&#46;&#x32;&#x31;&#57;&#46;&#x31;&#x33;&#x36;:&#x2F;usr&#x2F;local&#x2F;nginx\n意思是  把dist目录  发送到服务器ip为……..的&#x2F;usr&#x2F;local&#x2F;nginx\n文件夹就是放到nginx下的和默认index平级的\n这样的话就重启nginx    ，vue项目就成功了！！！！！！！！！！！！！\n如果点页面的话有可能出现404  解决方案\n在server下location 下加try_files $uri $uri&#x2F; &#x2F;index.html;\n涉及到的命令\n启动nginx的命令为   /usr/local/nginx/sbin/nginx \n\n停止nginx的命令为  /usr/local/nginx/sbin/nginx -s stop重启nginx的命令为  /usr/local/nginx/sbin/nginx -s reload\n\nlinux 进入编辑文件       i\n编辑完成后推出    esc  \n:wq推出并保存\n"},{"title":"虚拟dom和diff算法","url":"/2021/05/18/%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/","content":"x先来说什么是虚拟dom\n虚拟dom是一个对象，一个用来表示真实dom的对象，\n比如左边是真实dom，右边是对应的虚拟dom\n\n虚拟DOM比真实DOM快这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？\n虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM，虚拟DOM和虚拟DOM算法是两种概念。虚拟DOM算法 = 虚拟DOM + Diff算法\n那什么是diff算法？diff算法是一种对比算法，对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点改变了， 并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没有发生改变的节点，实现精准地更新真实DOM，进而提高效率，\nDiff算法的原理？新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行，不会跨层级比较，\nDiff对比流程当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher,订阅者们就会调用patch方法，给真实DOM打补丁，更新对应的视图\n","categories":["Vue"]},{"title":"面试题（非技术问题）","url":"/2019/05/17/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/","content":"\n回想下你遇见过最难打交道的同事，你是如何跟他沟通的一般来说，工作中总会遇见一两个自己不喜欢的人，这种情况应该尽量避免冲突，自己主动多做一些事情，比如规划好工作安排，让对方感觉到自己的合作精神\n当你被分配一个几乎不可能完成的任务时，你会怎么做自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间能不能借助周围同事来解决问题拿着分析结果跟上级反馈，寻求帮助或者资源\n业余时间都做什么？除了写码之外还有什么爱好和朋友一起去做做运动，比如打篮球，也会聚会聊天或去打台球等；假期也会跟朋友去旅游，现在疫情的话在家会   去B站上看一些新技术。   然后用新技术做个小项目或者实现个小功能之类的。（vue3，git，人脸识别等等）\n让你回忆下你做过的项目中，最值得分享（最大型&#x2F;最困难&#x2F;最能体现技术能力&#x2F;最难忘）的介绍项目背景    1.这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？\n2. 承担角色\n3. 最终的结果和收益\n4. 有始有终：项目总结和反思\t\n\n如果让你负责一个项目，你会怎么做技术选型方面：\n\n时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？\n团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？\n业务需求：需求是怎样的，能否套用现在的成熟解决方案&#x2F;库来快速解决？\n维护成本：一个解决方案的是否再能够 cover 住的范围之内？\n\nHR会问在之前的薪资，然后回答现在的薪资我之前薪资是23k ，加上一些，福利，季度奖金等，综合薪资是25k\n所以我的薪资目标是不低于 25k\nHR薪资给不到    怎么办肯定是给不到的，一定会压，\n  以现在北京的薪资区间，和身边朋友的参考， 我既然选择了这个薪资，我肯定是认为我的技术水平可以达到，  当然我刚才也跟您聊到了，我离职的原因是我想找到更好的发展前景，否则的话我就不会进行离职了，如果贵公司发展前景，比较好的话，我也会进行选择。  到公司后我也会通过我的努力继续前进，然后拿到我的期望薪资，\n但是我还是希望我可以拿到25k这个薪资，因为人往高处走嘛，我之前也已经拿到了25k，我也希望贵公司可以根据我的技术水平来给到我一个合理的薪资，\n谈加班问题如何看待加班问题？\n答： 首先，我是一个很注重效率，不拖拉的一个人，所有的工作我都会在规定时间内完成，如果因为我个人的问题影响了项目进度，或影响了大家，我自己就会选择加班完成进度，  另外  如果在工作中，公司或者项目需要我，也没有任何问题\n家庭情况如何看待跳槽问题这个跳槽问题，比如我，我从上一家离职\n与领导建议冲突时，咋整？我是比较冷静的，\n就举一个我在上一家公司的例子，  当时一个项目方案与领导的冲突了，自己感觉还是自己那个适合，然后又问了一下几个同事，才知道， 领导要考虑很多方面，比如  这个方案解决的时间长短，学习成本等，\n缺点是什么？我有时候急于求成，或者说做事急躁。一旦接手一个任务，总是想要尽快把它赶完，总觉得做完了一件事情心里才舒服。但是欲速则不达，太追求效率，就会牺牲质量。我现在总是提醒自己质量第一位，效率第二位，这样就会好得多。\n在工作中难忘的事情在过往的工作经历，让我收获了很多，也有很多难忘的事情，我举一个在项目的事情，\n当时开发一个教育考试平台，有一个防作弊功能模块，\n收获是什么技术方面，刚才也跟您提到了，我在做项目的时候有在用新的技术栈进行编写，所以，不但巩固了我现有的技术，而且让我学习到了新的技术比如vue3和数据分析方面，人脸识别等等，\n通过工作，让我的沟通能力，创新能力有了很大的提高，\n面试后的提问环节面试后的提问环节公司有没有定期的培训\n咱们公司有没有每年考核晋升的机会\n薪资构成，和福利待遇\n汇报线，  项目的进度，项目的性质，晋升路径，\n创新能力，冷静，执行力\n"},{"title":"高频面试题总结","url":"/2022/04/30/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","content":"高频考点面试题总结：面试题 链接：\n前端面试指南 ：\nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#x31;&#x38;&#x30;&#49;&#48;&#x30;&#55;&#x37;&#x30;&#x32;&#54;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\n1，typeof类型判断\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型\n如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的\nstr instanceof String &#x2F;&#x2F; false\n\n2，类型转换首先我们要知道，在 JS 中类型转换只有三种情况，分别是：\n\n转换为布尔值\n转换为数字\n转换为字符串\n\n4， &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换\n对于 === 来说，就是判断两者类型和值是否全相同,\n5，闭包闭包是可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，\n创建一个闭包最简单的方法就是在一个函数中创建另一个函数，\n闭包存在的意义就是让我们可以间接访问函数内部的变量\n另外它有三个特性：\n1，函数内可以再嵌套函数。2，内部函数可以访问外部的方法和变量。3，方法和变量不会被垃圾回收机制回收。\n“垃圾回收机制(简称GC), python解释器自带的一种机制 它是一种动态存储管理技术,自动释放不再被程序引用的对象所占用的内存空间”\n循环中使用闭包解决 var 定义函数的问题\n\n第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\n6 ，深浅拷贝浅拷贝：可以通过 Object.assign\n深拷贝：JSON.parse(JSON.stringify(object))\nJOSN.parse(JOSN.stringify())\n浅拷贝 通过 object.assign         会拷贝所有属性到新对象中，如果属性值是对象的话，就拷贝它的地址。\n深拷贝 通过JSON.parse(JSON.stringify(object))\n7，原型每个函数都有一个属性 proto 这个就是该函数的原型,原型链就是多个对象 通过__proto__的方式连接了起来\n8，let  const   var 的区别var声明的变量是全局变量，也是顶层变量，存在变量提升的情况，我们可以对一个变量进行多次声明，后面的会覆盖前面的\nlet是es6新增的命令，let声明的变量只在所在的代码块有效，不存在变量提升，不允许在同一作用域内重复声明\nconst声明一个只读的变量，一旦声明不可改变，\n9,原型继承和class继承原型继承:就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。\nclass继承:\nclass 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。\n10,模块化?模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能\n\n解决命名冲突\n提供复用性\n提高代码可维护性\n\n11,实现一个简洁版的promise12.** Event Loop**进程与线程本质上来说，两个名词都是 CPU 工作时间片的一个描述。\n进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序\n线程是进程中的更小单位，描述了执行一段指令所需的时间\n执行栈可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则\n浏览器中的 Event Loop14,new因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题\n15,instanceof 的原理instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype\n\n实现一下 instanceof\n\n首先获取类型的原型\n然后获得对象的原型\n然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null\n\n","categories":["面试题总结"]}]