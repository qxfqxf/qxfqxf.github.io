[{"title":"高频考点面试题总结","url":"/2022/04/30/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E5%9F%BA%E7%A1%80%E7%AF%87)/","content":"高频考点面试题总结：面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#x38;&#x30;&#x31;&#48;&#48;&#x37;&#55;&#48;&#x32;&#54;&#64;&#49;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\n1，typeof类型判断\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型\n如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的\nstr instanceof String &#x2F;&#x2F; false\n\n2，类型转换首先我们要知道，在 JS 中类型转换只有三种情况，分别是：\n\n转换为布尔值\n转换为数字\n转换为字符串\n\n4， &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换\n对于 === 来说，就是判断两者类型和值是否全相同,\n5，闭包闭包是可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，\n创建一个闭包最简单的方法就是在一个函数中创建另一个函数，\n闭包存在的意义就是让我们可以间接访问函数内部的变量\n另外它有三个特性：\n1，函数内可以再嵌套函数。2，内部函数可以访问外部的方法和变量。3，方法和变量不会被垃圾回收机制回收。\n“垃圾回收机制(简称GC), python解释器自带的一种机制 它是一种动态存储管理技术,自动释放不再被程序引用的对象所占用的内存空间”\n循环中使用闭包解决 var 定义函数的问题\n\n第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\n6 ，深浅拷贝浅拷贝：可以通过 Object.assign\n深拷贝：JSON.parse(JSON.stringify(object))\nJOSN.parse(JOSN.stringify())\n浅拷贝 通过 object.assign         会拷贝所有属性到新对象中，如果属性值是对象的话，就拷贝它的地址。\n深拷贝 通过JSON.parse(JSON.stringify(object))\n7，原型每个函数都有一个属性 proto 这个就是该函数的原型,原型链就是多个对象 通过__proto__的方式连接了起来\n8，let  const   var 的区别var声明的变量是全局变量，也是顶层变量，存在变量提升的情况，我们可以对一个变量进行多次声明，后面的会覆盖前面的\nlet是es6新增的命令，let声明的变量只在所在的代码块有效，不存在变量提升，不允许在同一作用域内重复声明\nconst声明一个只读的变量，一旦声明不可改变，\n9,原型继承和class继承原型继承:就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。\nclass继承:\nclass 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。\n10,模块化?模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能\n\n解决命名冲突\n提供复用性\n提高代码可维护性\n\n11,实现一个简洁版的promise12.** Event Loop**进程与线程本质上来说，两个名词都是 CPU 工作时间片的一个描述。\n进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序\n线程是进程中的更小单位，描述了执行一段指令所需的时间\n执行栈可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则\n浏览器中的 Event Loop14,new因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题\n15,instanceof 的原理instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype\n\n实现一下 instanceof\n\n首先获取类型的原型\n然后获得对象的原型\n然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null\n\n","categories":["面试题总结"]},{"title":"高频考点面试题总结","url":"/2022/05/03/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E8%BF%9B%E9%98%B6%E7%AF%87)/","content":"面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#x31;&#56;&#48;&#x31;&#x30;&#48;&#x37;&#x37;&#48;&#50;&#54;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\n类型及检测方式JavaScript一共有8种数据类型，7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；\n1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）\nJS数据类型分为两类进行存储：\n基本数据类型：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n引用数据类型：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\nJavaScript 中的数据是如何存储在内存中的？在 JavaScript 中，基本类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\n在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间、堆空间。其中的代码空间主要是存储可执行代码的，原始类型(Number、String、Null、Undefined、Boolean、Symbol、BigInt)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。\n因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在”堆空间”中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。\n数据类型检测（1）typeof\n​\t\t\ttypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n​\t\t\ttypeof对于对象来说，除了函数都会显示object\n，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n2）instanceof\n​\tinstanceof可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype\n数据类型转换首先我们要知道，在 JS 中类型转换只有三种情况，分别是：\n\n转换为布尔值\n转换为数字\n转换为字符串\n\nnull 和 undefined 的区别？ 首先 Undefined 和 Null 都是基本数据类型，\nundefined 代表的含义是未定义， null 代表的含义是空对象\nThisthis总是指向函数的直接调用者，当有new关键字时，this会指向new出来的那个对象，\n函数执行改变this\ncall: fn.call(target, 1, 2)\napply: fn.apply(target, [1, 2])\nbind: fn.bind(target)(1,2)\n\napply&#x2F;call&#x2F;bind 原理变量提升通常提升的解释是说将声明的代码移动到了顶部，\n更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用\n执行上下文当执行 JS 代码时，会产生三种执行上下文\n\n全局执行上下文\n函数执行上下文\neval 执行上下文\n\n\n每个执行上下文中都有三个重要的属性\n\n\n变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问\n作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）\nthis\n\n作用域作用域： 作用域是定义变量的区域，\n作用域可以理解为变量的可访问性，总共分为三种类型，分别为：\n\n全局作用域 &#x3D;&#x3D;&gt;\t全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量\n函数作用域 &#x3D;&#x3D;&gt;     函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域\n块级作用域 &#x3D;&#x3D;&gt;     ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。\n\n作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n闭包闭包其实就是一个可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，创建一个闭包最常见的方法就是在一个函数中创建另一个函数，它有三个特性，1：函数内可以再嵌套函数，2：内部函数可以访问外部的方法和变量，3：方法和变量不会被垃圾回收机制回收，\nNew的原理\n创建一个新对象\n对象连接到构造函数原型上，并绑定 this（this 指向新对象）\n执行构造函数代码（为这个新对象添加属性）\n返回新对象\n\nnew 被调用后大致做了哪几件事情\n让实例可以访问到私有属性；\n让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性；\n构造函数返回的最后结果是引用数据类型。\n\n原型&#x2F;原型链原型在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。\n原型链当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，直到找到或undefined，这个就是原型链的概念。\n\n原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__(非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。\n构造函数: 可以通过new来 新建一个对象 的函数。\n实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。\n\njs 获取原型的方法\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n\n继承1，组合继承\t\t组合继承是最常用的继承方式\n2，Class 继承\n面向对象\n基本思想是使用对象，类，继承，封装等基本概念来进行程序设计\n\n优点\n\n易维护\n采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的\n\n\n易扩展\n开发工作的重用性、继承性高，降低重复工作量。\n缩短了开发周期\n\n\n\n一般面向对象包含：继承，封装，多态，抽象\n事件机制事件流有三个阶段\n\n事件捕获阶段\n处于目标阶段\n事件冒泡阶段\n\n事件捕获\n\n事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件\n\n事件冒泡\n\n事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点\n\n无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播\n模块化\njs 中现在比较成熟的有四种模块加载方案：\n\n\n第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。\n第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范\n第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。\n第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块\n\nAMD 和 CMD 规范的区别？第一个方面是在模块定义时对依赖的处理不同，AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。\n第二个方面是对依赖模块的执行时机处理不同，首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，\n谈谈对模块化开发的理解\n我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。\n由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。\n后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。\n现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。\n\nIterator迭代器Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\nIterator 的作用有三个：\n\n创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\nPromise\nPromise 是 ES6 新增的语法，解决了回调地狱的问题。\n\n回调地狱概念：回调函数套回调函数的情况就叫做回调地狱，\n\n可以把 Promise看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。\n\n简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息\n一般 Promise 在执行过程中，必然会处于以下几种状态之一。\n\n待定（pending）：初始状态，既没有被完成，也没有被拒绝。\n已完成（fulfilled）：操作成功完成。\n已拒绝（rejected）：操作失败。\n\nGeneratorGenerator 是 ES6中新增的语法，和 Promise 一样，都可以用来异步编程。Generator 最大的特点就是可以控制函数的执行。\nGenerator函数是ES6提供的一种异步编程解决方案。通过yield标识位和next()方法调用，实现函数的分段执行\nasync&#x2F;awaitGenerator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。\n优缺点：async/await的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。\nasync原理\nasync/await语法糖就是使用Generator函数+自动执行器来运作的\n事件循环\n首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行\n\n在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务\n\n当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行\n\n任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行\n\n当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。\n\n微任务：在 Node.js 中微任务包含 2 种——process.nextTick 和 Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且process.nextTick 和 Promise也存在优先级，process.nextTick 高于 Promise\n\n宏任务\n在 Node.js 中宏任务包含 4 种——setTimeout、setInterval、setImmediate 和 I/O。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列\n\n\n垃圾回收\nJavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。\n\n针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数\n\n\n标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。\n内存泄露意外的全局变量\n定时器\n事件监听:\n闭包\n循环对象引用:\n控制台console.log打印的东西\n深浅拷贝浅拷贝自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象\n但是使用 object.assign 方法有几点需要注意\n\n它不会拷贝对象的继承属性；\n它不会拷贝对象的不可枚举的属性；\n可以拷贝 Symbol 类型的属性。\n\n深拷贝浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。\n深拷贝的原理可以总结如下\n将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。\n节流与防抖\n函数防抖 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n函数节流 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\nProxy代理proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截\nProxy的作用\n\n对于代理模式 Proxy 的作用主要体现在三个方面\n\n\n拦截和监视外部对对象的访问\n降低函数或类的复杂度\n在复杂操作前对操作进行校验或对所需资源进行管理\n\nAjax\nAjax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n\najax 有那些优缺点?\n\n优点：\n通过异步模式，提升了用户体验.\n优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\nAjax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\nAjax可以实现动态不刷新（局部刷新）\n\n\n缺点：\n安全问题 AJAX暴露了与服务器交互的细节。\n对搜索引擎的支持比较弱。\n不容易调试。\n\n\n\n","categories":["面试题总结"]},{"title":"Hello World","url":"/2022/04/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Vue面试题总结","url":"/2022/05/01/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","content":"面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#56;&#48;&#x31;&#48;&#x30;&#x37;&#55;&#x30;&#x32;&#x36;&#x40;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\nVue是什么Vue是一套用于构建用户界面的渐进式框架，所谓渐进式就是Vue只做自己改做的事情，不做职责以外的事，Vue的核心库只关注视图层，\n非常容易与其它库或已有项目整合\nVue响应式原理\nVue 的响应式原理是核心是通过  Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上。\n\n发布订阅模式和观察者模式\n观察者模式是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的\n发布&#x2F;订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在\n\n为什么使用 Virtual DOMVirtual DOM（虚拟DOM），是由普通的 JS 对象来描述DOM对象，因为不是真实的DOM对象，所以叫 Virtual DOM。\n\n手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题。\n虽然有 jQuery 等库简化 DOM 操作并解决了兼容性问题。但是随着项目的复杂，DOM操作复杂提升，既要考虑操作数据，又要考虑操作 DOM。\nVirtual DOM 的好处是，当状态改变时不需要立即更新 DOM，只需要创建一个虚拟 DOM 树来描述 DOM，Virtual DOM 内部将弄清楚如何有效（diff）的更新 DOM。内部使用 diff 算法，找到状态的差异，只更新变化的部分。\n补充1��VDOM 的必要性？\n创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。\n触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。\n\n\n\nVDOM：三个 part\n虚拟节点类，将真实 DOM节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM\n节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象\nre-render：解析 patch 对象，进行 re-render\n\nvue 和 react技术选型相同点：\n\n数据驱动页面，提供响应式的试图组件\n都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范\n数据流动单向，都支持服务器的渲染SSR\n都有支持native的方法，react有React native， vue有wexx\n\n不同点：\n\n数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的\n数据渲染：大规模的数据渲染，react更快\n使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目\n开发风格：react推荐做法jsx + inline style把html和css都写在js了\n\nnextTicknextTick` 可以让我们在下次 `DOM` 更新循环结束之后执行延迟回调，用于获得更新后的 `DOM\n\nnextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用\n\nPromise\nMutationObserver\nsetImmediate\n如果以上都不行则采用setTimeout\n\nVue生命周期首先，我们先来了解一下‘’生命周期‘’这个词\n通俗来讲，生命周期就是一个事务从出生到消失的过程\n在vue中，vue的生命周期是指：从创建vue对象到销毁vue对象的过程，\n钩子函数是Vue框架中内置的一些函数，随着生命周期\t阶段，自动执行，\nbeforeCreate\tcreated\tbeforeMount\tmounted\tbeforeUpdate\tupdated\tbeforeDestroy\tdestroyed\terrorCaptured\nvue-routerVue Router 是 Vue.js 的官方路由，让用 Vue.js 构建单页应用变得轻而易举。\nmode:hash   history\n跳转：\nthis.$router.push()\t\t&lt;router-link to = &#x27; &#x27;&gt;&lt;/router-link&gt;\n\n占位：\n&lt;router-view&gt;&lt;/router-view&gt;\n\nvuexVuex 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化\n核心概念\n\nstate: 状态中心\nmutations: 更改状态\nactions: 异步更改状态\ngetters: 获取状态\nmodules: 将state分成多个modules，便于管理\n\nvue3带来的新特性&#x2F;亮点1. 压缩包体积更小\n​\t当前最小化并被压缩的 Vue 运行时大小约为 20kB（2.6.10 版为 22.8kB）。Vue 3.0捆绑包的大小大约会减少一半，即只有10kB！\n2. Object.defineProperty -&gt; Proxy\n3. Virtual DOM 重构\n细致内容：https://interview2.poetries.top/docs/simply.html#_11-compositon-api\n","categories":["面试题总结"]},{"title":"Vue3 笔记","url":"/2022/04/29/vue3biji/","content":"1，什么是组合式的API?将相关联的代码保持在了一起，那么我们的代码将更具有可读性，因此也更具有可维护性。\nsetup组件选项setup有两个参数， props  和 context\n1,setup 函数中的第一个参数是 props。setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，(不能直接console.log(props.title)   &#x3D;&gt;&gt;undinfd) ，它会消除 prop 的响应性。 \n所以要使用toRefs\nconst &#123; title &#125; = toRefs(props)console.log(title.value)\n\n2,传递给 setup 函数的第二个参数是 context。context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：\n响应式变量 ref，reactive在 Vue 3.0 中，我们可以通过一个新的 ref 函数使任何响应式变量在任何地方起作用\nvue2选项式API\nvue3组合式API\ntoref()  映射一个方法\ntorefs() 映射全部方法\ntoRefs?\n计算属性和监听属性？计算属性 computed，  监听属性 wathch  watchEffect\n\n\n生命周期函数：主要有三个：\n组件诞生：onMounted（）\n组件更改：onUpdated（）\n组件卸载：onUnmounted（）\n全局属性：在main.js中设置例如设置axios   &#x3D;&gt;&gt;   app.config.globalProperties.http &#x3D; axios \nvue3实例获取：因为vue3中不能用this，所以要使用另一个方法getCurrentInstance  具体用法，下方：\n\n数组赋值：不能直接给数组等于   例如要改变列表的话要使用   tolist.push(…res.data)\n组件传值：父传子：\n子传父：\n兄弟传值：\nprovide  inject 传值方法直接定义，然后取就可以  很简单，不过使用的时候都要导入  \n\n\nvue3中代码复用 Mixin在入口文件main.js中定义即可\n\n过滤器全局过滤器\n注册\n使用\n","categories":["Vue3"]},{"title":"搭建博客流程/问题","url":"/2022/04/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98/","content":"Welcome to 第一篇文章，我在这里记录我创建博客时的问题流程dir\t查询文件目录hexo serve 启动hexo n “我的第一篇文章”hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写\n添加标签： 在需要添加标签的文章里在data后加\ncategories：  \n​\t- Python\n部署到github  需要下载hexo-deployer-git需要到_config.yml下的Deployment去配置type&#x3D;”git”和git地址然后就可以进行部署  hexo d \n问题–都为两个—-\n1， 配置你的github用户名和和邮箱，\n​\t\tgit config –global user.email “&#x64;&#x61;&#109;&#x69;&#x6e;&#x67;&#x31;&#x37;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;“ \n​\t\tgit config –global user.name “daming-Z”\n2，取消git本身的https代理，使用自己本机的代理，\n​\t\t取消http代理* \t  git config –global –unset http.proxy \n​\t\t取消https代理*  \tgit config –global –unset https.proxy\n3，生成github令牌流程\n​\t\thttps://blog.csdn.net/yjw123456/article/details/119696726\n4，keep主题的配置\n​\t\thttps://zhuanlan.zhihu.com/p/368244108\n参考 bilibiliup \nhttps://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click\n设置主题\nhttps://hexo.io/themes/\n"},{"title":"杂七杂八","url":"/2022/04/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/","content":"JS更新页面代码location.reload()\nVUE中样式只在当前页面生效 只需要在style中加上scoped\n使用原生js写一个删除提示弹出框原本的删除方法用自定义的包装一下：\t        if(confirm(‘确定要删除吗’)&#x3D;&#x3D;true){                    this.handleDelete(row)        }\nWindows设置自己的程序开机自动启动cmd打开运行，输入shell:startup，回车，也可以快速打开启动文件夹。把需要开机启动的快捷方式拉到目录下\nJavaScript setTimeout() 用法setTimeout(“alert(‘对不起, 要你久候’)”, 3000 )\n"}]