[{"title":"Vue面试题总结","url":"/2022/05/01/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","content":"面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#56;&#48;&#x31;&#48;&#48;&#55;&#55;&#x30;&#50;&#x36;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\nVue响应式原理\nVue 的响应式原理是核心是通过  Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上。\n\n发布订阅模式和观察者模式\n观察者模式是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的\n发布&#x2F;订阅模式由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在\n\n为什么使用 Virtual DOMVirtual DOM（虚拟DOM），是由普通的 JS 对象来描述DOM对象，因为不是真实的DOM对象，所以叫 Virtual DOM。\n\n手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题。\n虽然有 jQuery 等库简化 DOM 操作并解决了兼容性问题。但是随着项目的复杂，DOM操作复杂提升，既要考虑操作数据，又要考虑操作 DOM。\nVirtual DOM 的好处是，当状态改变时不需要立即更新 DOM，只需要创建一个虚拟 DOM 树来描述 DOM，Virtual DOM 内部将弄清楚如何有效（diff）的更新 DOM。内部使用 diff 算法，找到状态的差异，只更新变化的部分。\n补充1��VDOM 的必要性？\n创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。\n触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。\n\n\n\nVDOM：三个 part\n虚拟节点类，将真实 DOM节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM\n节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象\nre-render：解析 patch 对象，进行 re-render\n\nvue 和 react技术选型相同点：\n\n数据驱动页面，提供响应式的试图组件\n都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范\n数据流动单向，都支持服务器的渲染SSR\n都有支持native的方法，react有React native， vue有wexx\n\n不同点：\n\n数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的\n数据渲染：大规模的数据渲染，react更快\n使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目\n开发风格：react推荐做法jsx + inline style把html和css都写在js了\n\nnextTicknextTick` 可以让我们在下次 `DOM` 更新循环结束之后执行延迟回调，用于获得更新后的 `DOM\n\nnextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用\n\nPromise\nMutationObserver\nsetImmediate\n如果以上都不行则采用setTimeout\n\nVue生命周期beforeCreate\tcreated\tbeforeMount\tmounted\tbeforeUpdate\tupdated\tbeforeDestroy\tdestroyed\terrorCaptured\nvue-routermode:hash   history\n跳转：\nthis.$router.push()\t\t&lt;router-link to = &#x27; &#x27;&gt;&lt;/router-link&gt;\n\n占位：\n&lt;router-view&gt;&lt;/router-view&gt;\n\nvuexVuex 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化\n核心概念\n\nstate: 状态中心\nmutations: 更改状态\nactions: 异步更改状态\ngetters: 获取状态\nmodules: 将state分成多个modules，便于管理\n\nvue3带来的新特性&#x2F;亮点1. 压缩包体积更小\n​\t当前最小化并被压缩的 Vue 运行时大小约为 20kB（2.6.10 版为 22.8kB）。Vue 3.0捆绑包的大小大约会减少一半，即只有10kB！\n2. Object.defineProperty -&gt; Proxy\n3. Virtual DOM 重构\n细致内容：https://interview2.poetries.top/docs/simply.html#_11-compositon-api\n","categories":["面试题总结"]},{"title":"Vue3 笔记","url":"/2022/04/29/vue3biji/","content":"1，什么是组合式的API?将相关联的代码保持在了一起，那么我们的代码将更具有可读性，因此也更具有可维护性。\nsetup组件选项setup有两个参数， props  和 context\n1,setup 函数中的第一个参数是 props。setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，(不能直接console.log(props.title)   &#x3D;&gt;&gt;undinfd) ，它会消除 prop 的响应性。 \n所以要使用toRefs\nconst &#123; title &#125; = toRefs(props)console.log(title.value)\n\n2,传递给 setup 函数的第二个参数是 context。context 是一个普通 JavaScript 对象，暴露了其它可能在 setup 中有用的值：\n响应式变量 ref，reactive在 Vue 3.0 中，我们可以通过一个新的 ref 函数使任何响应式变量在任何地方起作用\nvue2选项式API\nvue3组合式API\ntoref()  映射一个方法\ntorefs() 映射全部方法\ntoRefs?\n计算属性和监听属性？计算属性 computed，  监听属性 wathch  watchEffect\n\n\n生命周期函数：主要有三个：\n组件诞生：onMounted（）\n组件更改：onUpdated（）\n组件卸载：onUnmounted（）\n全局属性：在main.js中设置例如设置axios   &#x3D;&gt;&gt;   app.config.globalProperties.http &#x3D; axios \nvue3实例获取：因为vue3中不能用this，所以要使用另一个方法getCurrentInstance  具体用法，下方：\n\n数组赋值：不能直接给数组等于   例如要改变列表的话要使用   tolist.push(…res.data)\n组件传值：父传子：\n子传父：\n兄弟传值：\nprovide  inject 传值方法直接定义，然后取就可以  很简单，不过使用的时候都要导入  \n\n\nvue3中代码复用 Mixin在入口文件main.js中定义即可\n\n过滤器全局过滤器\n注册\n使用\n","categories":["Vue3"]},{"title":"搭建博客流程/问题","url":"/2022/04/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98/","content":"Welcome to 第一篇文章，我在这里记录我创建博客时的问题流程dir\t查询文件目录hexo serve 启动hexo n “我的第一篇文章”hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写\n添加标签： 在需要添加标签的文章里在data后加\ncategories：  \n​\t- Python\n部署到github  需要下载hexo-deployer-git需要到_config.yml下的Deployment去配置type&#x3D;”git”和git地址然后就可以进行部署  hexo d \n问题–都为两个—-\n1， 配置你的github用户名和和邮箱，\n​\t\tgit config –global user.email “&#100;&#x61;&#x6d;&#105;&#110;&#103;&#x31;&#x37;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;“ \n​\t\tgit config –global user.name “daming-Z”\n2，取消git本身的https代理，使用自己本机的代理，\n​\t\t取消http代理* \t  git config –global –unset http.proxy \n​\t\t取消https代理*  \tgit config –global –unset https.proxy\n3，生成github令牌流程\n​\t\thttps://blog.csdn.net/yjw123456/article/details/119696726\n4，keep主题的配置\n​\t\thttps://zhuanlan.zhihu.com/p/368244108\n参考 bilibiliup \nhttps://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click\n设置主题\nhttps://hexo.io/themes/\n"},{"title":"Hello World","url":"/2022/04/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"杂七杂八","url":"/2022/04/29/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/","content":"JS更新页面代码location.reload()\nVUE中样式只在当前页面生效 只需要在style中加上scoped\n使用原生js写一个删除提示弹出框原本的删除方法用自定义的包装一下：\t        if(confirm(‘确定要删除吗’)&#x3D;&#x3D;true){                    this.handleDelete(row)        }\nWindows设置自己的程序开机自动启动cmd打开运行，输入shell:startup，回车，也可以快速打开启动文件夹。把需要开机启动的快捷方式拉到目录下\nJavaScript setTimeout() 用法setTimeout(“alert(‘对不起, 要你久候’)”, 3000 )\n"},{"title":"面试题总结","url":"/2022/04/30/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","content":"面试题总结：面试题 链接：\n前端面试指南 \nhttps://interview2.poetries.top/docs/base.html\n邮箱：&#49;&#56;&#48;&#x31;&#x30;&#48;&#55;&#x37;&#x30;&#x32;&#x36;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;\nweb前端面试-面试官系列：\nhttps://vue3js.cn/interview/vue/vue.html\n1，typeof类型判断\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型\n如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的\nstr instanceof String &#x2F;&#x2F; false\n\n2，类型转换首先我们要知道，在 JS 中类型转换只有三种情况，分别是：\n\n转换为布尔值\n转换为数字\n转换为字符串\n\n4， &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 有什么区别对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换\n对于 === 来说，就是判断两者类型和值是否全相同,\n5，闭包闭包是可以访问其他函数内部变量的函数，我们通常用它来定义私有化的变量和方法，\n创建一个闭包最简单的方法就是在一个函数中创建另一个函数，\n闭包存在的意义就是让我们可以间接访问函数内部的变量\n另外它有三个特性：\n1，函数内可以再嵌套函数。2，内部函数可以访问外部的方法和变量。3，方法和变量不会被垃圾回收机制回收。\n“垃圾回收机制(简称GC), python解释器自带的一种机制 它是一种动态存储管理技术,自动释放不再被程序引用的对象所占用的内存空间”\n循环中使用闭包解决 var 定义函数的问题\n\n第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\n6 ，深浅拷贝浅拷贝：可以通过 Object.assign\n深拷贝：JSON.parse(JSON.stringify(object))\nJOSN.parse(JOSN.stringify())\n浅拷贝 通过 object.assign         会拷贝所有属性到新对象中，如果属性值是对象的话，就拷贝它的地址。\n深拷贝 通过JSON.parse(JSON.stringify(object))\n7，原型每个函数都有一个属性 proto 这个就是该函数的原型,原型链就是多个对象 通过__proto__的方式连接了起来\n8，let  const   var 的区别var声明的变量是全局变量，也是顶层变量，存在变量提升的情况，我们可以对一个变量进行多次声明，后面的会覆盖前面的\nlet是es6新增的命令，let声明的变量只在所在的代码块有效，不存在变量提升，不允许在同一作用域内重复声明\nconst声明一个只读的变量，一旦声明不可改变，\n9,原型继承和class继承原型继承:就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。\nclass继承:\nclass 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。\n10,模块化?模块化用来分割，组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能\n\n解决命名冲突\n提供复用性\n提高代码可维护性\n\n11,实现一个简洁版的promise12.** Event Loop**进程与线程本质上来说，两个名词都是 CPU 工作时间片的一个描述。\n进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序\n线程是进程中的更小单位，描述了执行一段指令所需的时间\n执行栈可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则\n浏览器中的 Event Loop14,new因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题\n15,instanceof 的原理instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype\n\n实现一下 instanceof\n\n首先获取类型的原型\n然后获得对象的原型\n然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null\n\n"}]